<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="j2ee学习之五-spring">
<meta property="og:type" content="article">
<meta property="og:title" content="spring学习">
<meta property="og:url" content="http://yoursite.com/2017/02/19/spring学习/index.html">
<meta property="og:site_name" content="Everything Changes">
<meta property="og:description" content="j2ee学习之五-spring">
<meta property="og:updated_time" content="2017-04-11T12:12:54.927Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="spring学习">
<meta name="twitter:description" content="j2ee学习之五-spring">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/02/19/spring学习/"/>





  <title> spring学习 | Everything Changes </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Everything Changes</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/19/spring学习/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="QxG">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Everything Changes">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Everything Changes" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                spring学习
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-19T08:57:24+08:00">
                2017-02-19
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/19/spring学习/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/19/spring学习/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>j2ee学习之五-spring</p>
<a id="more"></a>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>使用intellij创建spring项目，然后在src目录创建spring config xml文件。</p>
<p>接着创建一个bean类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class HelloWorld &#123;</div><div class="line"></div><div class="line">    private String name;</div><div class="line"></div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void hello()&#123;</div><div class="line">        System.out.println(&quot;hello,&quot; + name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在正常的main中执行HelloWorld方法的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HelloWorld hello = new HelloWorld();</div><div class="line">hello.setName(&quot;Spring&quot;);</div><div class="line">hello.hello();</div></pre></td></tr></table></figure></p>
<p>而在spring中则是这样实现，首先在spring config xml文件中配置，配置名为applicationContext.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</div><div class="line"></div><div class="line">    &lt;bean id=&quot;hello&quot; class=&quot;con.qxg.bean.HelloWorld&quot;&gt;</div><div class="line">        &lt;property name=&quot;name&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>bean标签就是配置一个实体类，而property就是配置该类中的属性。</p>
<p>这样在main方法中调用就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//1.创建Spring的IOC容器对象</div><div class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</div><div class="line"></div><div class="line">//2. 获取bean实例</div><div class="line">HelloWorld hello = (HelloWorld) ctx.getBean(&quot;hello&quot;);</div><div class="line"></div><div class="line">//3. 执行hello方法</div><div class="line">hello.hello();</div></pre></td></tr></table></figure>
<h1 id="配置bean"><a href="#配置bean" class="headerlink" title="配置bean"></a>配置bean</h1><h2 id="xml形式"><a href="#xml形式" class="headerlink" title="xml形式"></a>xml形式</h2><p>如上述简单用法中的bean的设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;hello&quot; class=&quot;con.qxg.bean.HelloWorld&quot;&gt;</div><div class="line">    &lt;property name=&quot;name&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>使用该方式的要求是 HelloWorld有一个无参的构造器</p>
<p>而ApplicationContext就是IOC容器，在使用的时候要对这个类进行初始化。</p>
<p>得到ApplicationContext对象后，使用该对象的getBean方法来取得相应的bean。</p>
<p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//1.创建Spring的IOC容器对象</div><div class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</div><div class="line"></div><div class="line">//2. 获取bean实例</div><div class="line">HelloWorld hello = (HelloWorld) ctx.getBean(&quot;hello&quot;);</div></pre></td></tr></table></figure></p>
<p>而getBean也可以通过传入类型来获取IOC容器中的bean：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HelloWorld hello = (HelloWorld)ctx.getBean(HelloWorld.class);</div></pre></td></tr></table></figure></p>
<p>但是这种方式的限制是bean配置中的这种类型的bean只有一个。</p>
<h3 id="bean的命名"><a href="#bean的命名" class="headerlink" title="bean的命名"></a>bean的命名</h3><p>bean的配置中,id即为其名,命名要求是必须以字母开头,后面是数字连字符,下划线,菊花,冒号等完整约束的符号.<br>但是如果用户确实希望用一些特殊字符进行命名,就需要使用name属性,name属性没有字符上的限制,几乎可以使用任何字符,如:?ab,123,这些都是合法的,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean name=&quot;#car&quot; class=&quot;com.qxg.bean.Car&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>id和name都可以指定多个名字,名字之间可用逗号,分号或空格进行分隔,如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean name=&quot;#car1,123,$car&quot; class=&quot;com.qxg.bean.Car&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>获取方式为:<code>getBean(&quot;#car1&quot;)</code>等.</p>
<p>但是spring不允许出现两个相同id的bean,但可以出现两个相同name的bean.如果有两个name相同的bean,那么通过getBean返回的对象,将会是最后定义的对象,原因是后定义的对象覆盖了之前的对象.所以为避免这种情况,一般只选择使用id为其命名.</p>
<p>如果未指明id,name则spring自动将全限定名作为bean的名称,可以通过<code>getBean(&quot;com.qxg.bean.Car&quot;)</code>来获取,而如果有多个实例类相同的匿名bean,如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.qxg.bean.Car&quot;/&gt;</div><div class="line">&lt;bean class=&quot;com.qxg.bean.Car&quot;/&gt;</div><div class="line">&lt;bean class=&quot;com.qxg.bean.Car&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>那么获取第一个bean的方式是<code>getBean(&quot;com.qxg.bean.Car&quot;)</code>,而获取第二个bean的方式是<code>getBean(&quot;com.qxg.bean.Car#1&quot;)</code></p>
<h3 id="constructor-arg"><a href="#constructor-arg" class="headerlink" title="constructor-arg"></a>constructor-arg</h3><p>在xml中配置bean时，属性的配置是使用property标签，这个标签对应的方法是setter方法，那么如果构造器中有传参的构造方法，怎么配置呢？</p>
<p>比如构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public HelloWorld(String name)&#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么配置方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;hello2&quot; class=&quot;con.qxg.bean.HelloWorld&quot;&gt;</div><div class="line">     &lt;constructor-arg value=&quot;Spring2&quot;&gt;&lt;/constructor-arg&gt;</div><div class="line"> &lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>其中constructor-arg就是表示构造方法中的参数，不制定位置的时候，会按照顺序和构造方法中的参数对应。</p>
<h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>那么如果规定其位置呢？</p>
<p>使用的是constructor-arg中的index属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;constructor-arg value=&quot;Spring2&quot; index=&quot;0&quot;&gt;&lt;/constructor-arg&gt;</div></pre></td></tr></table></figure>
<p>注意index是从0开始的。</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>但是如果构造器中有两个都是只有一个参数的构造方法呢？</p>
<p>那么这个时候只能通过type来指定其参数类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;constructor-arg value=&quot;Spring2&quot; type=&quot;java.lang.String&quot;&gt;&lt;/constructor-arg&gt;</div></pre></td></tr></table></figure>
<h3 id="CDATA"><a href="#CDATA" class="headerlink" title="![CDATA]"></a>![CDATA]</h3><p>对于特殊符号的value值怎么书写呢？比如设置值为<spring2>,因为&lt;&gt;为特殊值：</spring2></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;constructor-arg value=&quot;&lt;Spring2&gt;&quot; type=&quot;java.lang.String&quot;&gt;&lt;/constructor-arg&gt;</div></pre></td></tr></table></figure>
<p>这个时候编译器会报错，因为&lt;&gt;在xml文档中有特殊作用，不能被解析，那么这个时候需要用![CDATA]来包含其值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;constructor-arg type=&quot;java.lang.String&quot;&gt;</div><div class="line">    &lt;value&gt;![CDATA[&lt;Spring2&gt;]]&lt;/value&gt;</div><div class="line">&lt;/constructor-arg&gt;</div></pre></td></tr></table></figure></p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>比如下面的代码，一个人有一辆车，Car类为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Car &#123;</div><div class="line"></div><div class="line">    private String name;</div><div class="line">    private int size;</div><div class="line"></div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setSize(int size) &#123;</div><div class="line">        this.size = size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;[&quot; + name + &quot;,&quot; + size + &quot;]&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而对于Person的类为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Person &#123;</div><div class="line"></div><div class="line">    private Car car;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line"></div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setAge(int age) &#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCar(Car car) &#123;</div><div class="line">        this.car = car;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;[&quot; + name + &quot;,&quot; + age + &quot;,&quot; + car + &quot;]&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么配置就如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;car&quot; class=&quot;con.qxg.bean.Car&quot;&gt;</div><div class="line">    &lt;property name=&quot;name&quot; value=&quot;xuefulai&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;bean id=&quot;qxg&quot; class=&quot;con.qxg.bean.Person&quot;&gt;</div><div class="line">    &lt;property name=&quot;name&quot; value=&quot;qxg&quot;/&gt;</div><div class="line">    &lt;property name=&quot;age&quot; value=&quot;21&quot;/&gt;</div><div class="line">    &lt;property name=&quot;car&quot; ref=&quot;car&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>可以看到Person的bean中使用的ref属性来引用第一个carbean。</p>
<p>也有其他写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;property name=&quot;car&quot;&gt;</div><div class="line">    &lt;ref bean=&quot;car&quot;/&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure></p>
<p>那么对于类而言有匿名内部类，bean里面可以配置匿名内部bean么？当然可以，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;qxg2&quot; class=&quot;con.qxg.bean.Person&quot;&gt;</div><div class="line">    &lt;property name=&quot;name&quot; value=&quot;qxg&quot;/&gt;</div><div class="line">    &lt;property name=&quot;age&quot; value=&quot;21&quot;/&gt;</div><div class="line">    &lt;property name=&quot;car&quot;&gt;</div><div class="line">        &lt;bean class=&quot;con.qxg.bean.Car&quot;&gt;</div><div class="line">            &lt;property name=&quot;name&quot; value=&quot;lanbojini&quot;/&gt;</div><div class="line">            &lt;property name=&quot;size&quot; value=&quot;21&quot;/&gt;</div><div class="line">        &lt;/bean&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>对于第三个参数，使用内部bean方法来配置，其中没有指明id，这就表明是匿名内部bean，不能被外部引用。</p>
<p>当然对于ref和内部bean也同样作用于constructor-arg标签内。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a><null></null></h3><p>如何给属性设置为null？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;property name=&quot;car&quot;&gt;&lt;null/&gt;&lt;/property&gt;</div></pre></td></tr></table></figure>
<h3 id="级联属性"><a href="#级联属性" class="headerlink" title="级联属性"></a>级联属性</h3><p>说白了，就是修改ref所引用的那个对象的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;qxg&quot; class=&quot;con.qxg.bean.Person&quot;&gt;</div><div class="line">    &lt;property name=&quot;name&quot; value=&quot;qxg&quot;/&gt;</div><div class="line">    &lt;property name=&quot;age&quot; value=&quot;21&quot;/&gt;</div><div class="line">    &lt;property name=&quot;car&quot; ref=&quot;car&quot;/&gt;</div><div class="line">    &lt;property name=&quot;car.name&quot; value=&quot;altername&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>即如上，在引用了car之后，在后边配置property，修改car.name的值，这就是级联。</p>
<p>但是要注意，如果要使用级联，一定要在Person类中有getCar这个方法，否则配置出错，因为无法取得car这个对象。</p>
<h3 id="集合属性"><a href="#集合属性" class="headerlink" title="集合属性"></a>集合属性</h3><p>直接上代码，一目了然：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;psesonNCar&quot; class=&quot;con.qxg.bean.PersonWithNCar&quot;&gt;</div><div class="line">    &lt;property name=&quot;cars&quot;&gt;</div><div class="line">        &lt;list&gt;</div><div class="line">            &lt;ref bean=&quot;car&quot;/&gt;</div><div class="line">            &lt;ref bean=&quot;car&quot;/&gt;</div><div class="line">        &lt;/list&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>其中集合使用的是<list><set><map>等标签来进行配置，而内部使用ref来进行引用或者内部类来添加。注意数组也是使用<list></list></map></set></list></p>
<p>不过map比较特殊，这里来段代码说明一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;map&gt;</div><div class="line">    &lt;entry key=&quot;&quot; value=&quot;&quot;/&gt;</div><div class="line">    ...</div><div class="line">&lt;/map&gt;</div></pre></td></tr></table></figure>
<p>可以看到其通过entry标签来设置key,value值，但是如果是自定义的类作为Key，那么就要使用key-ref，当然也会有value-ref。</p>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>java中是有Properties这个类型的，其实就是保存key,valu一种集合。</p>
<p>那么对于bean中的配置为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;property name=&quot;props&quot;&gt;</div><div class="line">    &lt;props&gt;</div><div class="line">         &lt;prop key=&quot;somekey&quot;&gt;somevalue&lt;/prop&gt;</div><div class="line">         ...</div><div class="line">    &lt;/props&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure>
<h3 id="util"><a href="#util" class="headerlink" title="util"></a>util</h3><p>util用于定义独立的集合，这样其他bean对象就可以引用该集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;util:list id=&quot;cars&quot;&gt;</div><div class="line">    &lt;ref bean=&quot;car1&quot;/&gt;</div><div class="line">    &lt;ref bean=&quot;car2&quot;/&gt;</div><div class="line">&lt;/util:list&gt;</div></pre></td></tr></table></figure></p>
<p>这样cars就表示一个List集合，内容有car1,和car2，那么对于一个bean有List的引用，就可以使用cars这个名称为其进行配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;property name=&quot;cars&quot; ref=&quot;cars&quot;/&gt;</div></pre></td></tr></table></figure>
<p>util不仅包含list,还有一些map,set等多种属性。<br>不过如果要使用util，必须要在xml根部加上util的命名空间。</p>
<h3 id="p"><a href="#p" class="headerlink" title="p"></a>p</h3><p>p命名空间，对应property<br>首先导入p命名空间，p简化了bean的配置，如原配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;qxg&quot; class=&quot;con.qxg.bean.Person&quot;&gt;</div><div class="line">    &lt;property name=&quot;name&quot; value=&quot;qxg&quot;/&gt;</div><div class="line">    &lt;property name=&quot;age&quot; value=&quot;21&quot;/&gt;</div><div class="line">    &lt;property name=&quot;car&quot; ref=&quot;car&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>使用p后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;qxg&quot; class=&quot;con.qxg.bean.Person&quot; p:name=“qxg” p:age=&quot;21&quot; p:car-ref=&quot;car&quot;/&gt;</div></pre></td></tr></table></figure></p>
<h3 id="c"><a href="#c" class="headerlink" title="c"></a>c</h3><p>c命名空间主要是对应constructor-arg元素<br>使用方式是：<code>c:_0</code>,<code>c:_0-ref</code>,<code>c:car</code>,<code>c:car-ref</code><br>注意<code>_0</code>中的0表示参数的index，所以如果构造器可传入两个参数,那么可以使用<code>c:_1</code>来指明第二个参数传入的值。</p>
<h3 id="自动装配-不推荐使用"><a href="#自动装配-不推荐使用" class="headerlink" title="自动装配(不推荐使用)"></a>自动装配(不推荐使用)</h3><p>autowire属性来自动装配，如以下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;bean id=&quot;car&quot; class=&quot;con.qxg.bean.Car&quot; p:name=&quot;xuefulannnnn&quot; p:size=&quot;20&quot; /&gt;</div><div class="line">&lt;bean id=&quot;person&quot; class=&quot;con.qxg.bean.Person&quot; p:age=&quot;10&quot; p:car-ref=&quot;car&quot; p:name=&quot;haha&quot;/&gt;</div></pre></td></tr></table></figure>
<p>最开始的写法如上，person中有car的引用，那么使用自动装配来写如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;car&quot; class=&quot;con.qxg.bean.Car&quot; p:name=&quot;xuefulannnnn&quot; p:size=&quot;20&quot; /&gt;</div><div class="line">&lt;bean id=&quot;person&quot; class=&quot;con.qxg.bean.Person&quot; p:age=&quot;10&quot; autowire=&quot;byName&quot; p:name=&quot;haha&quot;/&gt;</div></pre></td></tr></table></figure>
<p>其中person的bean配置中没有了ref引用，而是换成了autowire，值是byName,这个值的意思是，会根据set方法中的名字来查找是否有该名字的类对象，比如setCar，就会找名为car的Car对象，但是如果把car的名字改为car2，这种方法就会失效。</p>
<p>第二种方法为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;person&quot; class=&quot;con.qxg.bean.Person&quot; p:age=&quot;10&quot; autowire=&quot;byType&quot; p:name=&quot;haha&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>值为byType，根据类型装配，但是限制条件是该配置文件中，只有一个该类型的bean对象，即Car对象必须唯一。</p>
<p>看上去实际上很方便，但是也是有缺点的，比如不灵活，配置文件多的时候复杂不方便。一般项目中是不推荐使用的。</p>
<h3 id="配置中的继承"><a href="#配置中的继承" class="headerlink" title="配置中的继承"></a>配置中的继承</h3><p>注意是配置间的继承，并不是类中的继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;person&quot; class=&quot;con.qxg.bean.Person&quot; p:age=&quot;10&quot; autowire=&quot;byName&quot; p:name=&quot;haha&quot;/&gt;</div><div class="line">&lt;bean id=&quot;person2&quot; parent=&quot;person&quot; p:name=&quot;继承后的person&quot;/&gt;</div></pre></td></tr></table></figure>
<p>person2和person的类是一样的，但是我不想再多余的配置这个class这个属性，所以使用继承的方法，制定parent为person，这样就不用配置多余的属性。但是注意，autowire这个属性是不会被继承的。同时子bean是可以复写父bean的任何属性，包括class。</p>
<p>因为bean中可以继承，所以可以创建一个bean模板，并加上abstract=“true”,表示为抽象bean，不能被实例化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;person&quot; class=&quot;con.qxg.bean.Person&quot; p:age=&quot;10&quot; p:car-ref=&quot;car&quot; p:name=&quot;haha&quot; abstract=&quot;true&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>如果在配置bean的时候没有配置class，那么这个bean必须是抽象bean，即abstract=”true”必须被设置。</p>
<h3 id="配置中的依赖"><a href="#配置中的依赖" class="headerlink" title="配置中的依赖"></a>配置中的依赖</h3><p>使用depends-on，表示配置该bean前，依赖的bean对象一定先实例化，如果有过个bean，使用,隔开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;person&quot; class=&quot;con.qxg.bean.Person&quot;</div><div class="line">         p:age=&quot;10&quot;  p:name=&quot;haha&quot; depends-on=&quot;car&quot;/&gt;</div></pre></td></tr></table></figure>
<p>目前测试这个东西有问题，不知道什么原因。</p>
<h3 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h3><p>默认使用getBean来取得对象时，取得的对象都是同一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Person person = (Person) ctx.getBean(&quot;person&quot;);</div><div class="line">Person person2 = (Person) ctx.getBean(&quot;person&quot;);</div><div class="line">person.setName(&quot;修改后的值&quot;);</div><div class="line">System.out.println(person2);</div></pre></td></tr></table></figure>
<p>打印日志为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[修改后的值,10,[xuefufufufuufu,20]]</div></pre></td></tr></table></figure></p>
<p>即默认的scope是单例的，那么配置作用域使用的是scope，其值有2个：</p>
<ul>
<li>prototype:每次getBean都会返回新的bean。</li>
<li>singleton:单例</li>
</ul>
<p>使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;person&quot; class=&quot;con.qxg.bean.Person&quot; scope=&quot;prototype&quot;</div><div class="line">      p:age=&quot;10&quot;  p:name=&quot;haha&quot; p:car-ref=&quot;car&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>注解@Scope的使用方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Scope(&quot;prototype&quot;)</div><div class="line">@Component</div><div class="line">public class Car&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用外部属性文件"><a href="#使用外部属性文件" class="headerlink" title="使用外部属性文件"></a>使用外部属性文件</h3><p>有时候配置bean的时候需要使用系统部署的细节信息，比如文件路径等，数据源配置信息等。<br>Spring提供了一个PropertyPlaceholderConfigurer的BeanFactory后置处理器。</p>
<p>比如通过c3p0来配置数据库，写法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</div><div class="line">    &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</div><div class="line">    &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</div><div class="line">    &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;</div><div class="line">    &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/spring&quot;&gt;&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>配置前记得添加c3p0的两个jar包，和mysql的jar包。</p>
<p>这样配置似乎是没有问题，但是如果我们想要更改账户名称密码等呢？只能更改这个xml文件，但是难免会碰到一些复杂的问题，所以一般是创建一些配置文件，将这些配置放进去。比如创建一个文件叫db.propertied,然后写入配置信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">user=root</div><div class="line">password=root</div><div class="line">driverclass=com.mysql.jdbc.Driver</div><div class="line">jdbcurl=jdbc:mysql:///spring</div></pre></td></tr></table></figure>
<p>那么如何取出这些值呢？通过context命名空间来导入db.properties文件。</p>
<p>一种导入配置文件的方式是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</div><div class="line">        p:location=&quot;classpath:beansConfig.xml&quot;</div><div class="line">          p:fileEncoding=&quot;utf-8&quot;</div><div class="line">    /&gt;</div></pre></td></tr></table></figure></p>
<p>该类中还有其他很多属性,比如locations指定多个配置文件,order指定配置文件的顺序,placeholderPrefix修改取值时候的前缀,默认为<code>${</code>,placeholderSuffix修改取值后缀,默认为<code>}</code>.</p>
<p>另一种简单的配置方式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!--导入配置文件--&gt;</div><div class="line">&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</div><div class="line"></div><div class="line">&lt;!--通过$&#123;&#125;来读取配置文件中的值--&gt;</div><div class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</div><div class="line">    &lt;property name=&quot;user&quot; value=&quot;$&#123;user&#125;&quot;&gt;&lt;/property&gt;</div><div class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;&gt;&lt;/property&gt;</div><div class="line">    &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;driverClass&#125;&quot;&gt;&lt;/property&gt;</div><div class="line">    &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbcUrl&#125;&quot;&gt;&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>注意使用这种方式可能会一直警告：</p>
<blockquote>
<p>Establishing SSL connection without server’s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.</p>
</blockquote>
<p>只需要把配置文件中的jdbcurl的值设为：<code>jdbcUrl=jdbc:mysql://localhost:3306/spring?useSSL=false</code></p>
<p>如果配置属性文件后,想要在代码中引用,就要通过注解的方式,支持的注解是@Value,比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Value(&quot;$&#123;url&#125;&quot;)</div><div class="line">private String url;</div></pre></td></tr></table></figure></p>
<h3 id="使用加密文件"><a href="#使用加密文件" class="headerlink" title="使用加密文件"></a>使用加密文件</h3><p>如果直接在配置文件中存入数据库的URL,账号密码,虽然对于客户端不会构成威胁,但是对后台的所有开发人员都是透明了.而某些数据只允许掌握在少数人手中,这个时候就需要对数据进行加密.<br><code>PropertyPlaceholderConfigurer</code>继承自<code>PropertyResourceConfigurer</code>类,后者有几个有用的protected方法,用于在属性使用之前对属性进行转换处理:</p>
<ul>
<li>void convertProperties(Properties props):对所有的属性进行转换操作</li>
<li>String convertProperty(String propertyName,String propertyValue):在加载属性文件并读取文件中的每个属性时,都会调用此方法进行转换处理.</li>
<li>String convertPropertyValue(String originalValue):和上一个方法类似,只不过没有传入属性名.</li>
</ul>
<p>如果自定义了一个PropertyPlaceholderConfigurer后,那么就无法使用context来配置该类,只能通过bean的方式配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;org.springframework.beans.factory.config.MyPropertyPlaceholderConfigurer&quot;</div><div class="line">        p:location=&quot;classpath:beansConfig.xml&quot;</div><div class="line">          p:fileEncoding=&quot;utf-8&quot;</div><div class="line">    /&gt;</div></pre></td></tr></table></figure></p>
<h1 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h1><p>Spring表达式语言，支持运行时查询和操作对象图的强大的表达式语言。</p>
<p>语法：#{…},所有在大括号中的字符都被认为是SqEL.<br>语法中支持 基本运算符，三目运算符，正则表达式等。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>通常我们使用ref来引用其他对象，我们也可以通过#{}来引用其他对象，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;person&quot; class=&quot;con.qxg.bean.Person&quot; scope=&quot;prototype&quot;</div><div class="line">      p:age=&quot;10&quot;  p:name=&quot;haha&quot; p:car=&quot;#&#123;car&#125;&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>注意看car的引用变成了<code>p:car=&quot;#{car}&quot;</code>，原写法是：<code>p:car-ref=&quot;car&quot;</code></p>
<p>我们还可以通过#{…}来引用其他对象的属性，比如我想把car2中的name值设置为car中的name值，那么方法就是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;car2&quot; class=&quot;con.qxg.bean.Car&quot; p:name=&quot;#&#123;car.name&#125;&quot; p:size=&quot;846&quot;/&gt;</div></pre></td></tr></table></figure>
<p>并且#{…}还支持调用其他类中的方法，比如toString()等</p>
<h2 id="调用静态方法"><a href="#调用静态方法" class="headerlink" title="调用静态方法"></a>调用静态方法</h2><p>通过T()调用一个类的静态方法，它返回一个Class Object,然后再调用相应的方法和属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">value = &quot;#&#123;T(java.lang.Math).PI&#125;&quot;</div></pre></td></tr></table></figure></p>
<h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">value =&quot;#&#123;count&gt;30 ? &apos;呵&apos;:&apos;哈&apos;&#125;&quot;</div></pre></td></tr></table></figure>
<p>注意其中的字符串值要用单引号或双引号包括起来。</p>
<h1 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h1><p>首先有个lazy-init,指的懒加载。bean配置完成后，在应用启动完成后，所有的bean都会初始化，而如果制定lazy-init后，只有用到的时候才会初始化。一般用不到。</p>
<p>在注解中也可以标记延迟注解,不过是有要求的,如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Lazy</div><div class="line">@Respository</div><div class="line">public class LogDao&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class LogService&#123;</div><div class="line"></div><div class="line">	@Lazy</div><div class="line">	@Autowired</div><div class="line">	public void setLogDao(LogDao logDao)&#123;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上所示,@Lazy必须要同时标注在属性以及目标Bean上,二者缺一则延迟注解无效.</p>
<p>在bean的配置文件中，制定bean的init-method，和destroy-method，这样bean在初始化的时候会执行init-method，销毁的时候会执行destroy-method,如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;car2&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot; class=&quot;con.qxg.bean.Car&quot; p:name=&quot;#&#123;car.name&#125;&quot; p:size=&quot;846&quot;/&gt;</div></pre></td></tr></table></figure>
<p>在主代码中调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</div><div class="line">Car car = (Car) ctx.getBean(&quot;car2&quot;);</div><div class="line">System.out.println(car);</div><div class="line"></div><div class="line">ctx.close();</div></pre></td></tr></table></figure></p>
<p>其打印日志为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">init</div><div class="line">[xuefufufufuufu,846]</div><div class="line">destroy</div></pre></td></tr></table></figure>
<p>当然,代码中也有对应于init-method,destroy-method的方法,即<code>@PostConstruct</code>,<code>@PreDestroy</code>等注解,不过,注解可以标记多个方法,如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@PostConstruct</div><div class="line">private void init()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">@PostConstruct</div><div class="line">private void init2()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">@PreDestroy</div><div class="line">private void destroy()&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@PreDestroy</div><div class="line">private void destroy2()&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过注解名就知道,<code>@PostConstruct</code>是在构造函数后执行,<code>@PreDestroy</code>是在销毁前执行.<br>而其执行顺序是跟在类中方法的前后顺序有关.</p>
<h1 id="bean后置处理器"><a href="#bean后置处理器" class="headerlink" title="bean后置处理器"></a>bean后置处理器</h1><p>其实作用就是使用getBean取得bean对象的过程中，先对bean进行处理，然后才返回该bean。</p>
<p>比如我getBean(“car”)取得一个car，我想让所有Car类型的对象，都修改为名为”bmw”,那么方法就是配置后置处理器，创建一个类并实现BeanPostProcessor接口，并实现其中的两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class MyBeanPostProcess implements BeanPostProcessor &#123;</div><div class="line">    @Override</div><div class="line">    public Object postProcessBeforeInitialization(Object o, String s) throws BeansException &#123;</div><div class="line">        System.out.println(&quot;postProcessBeforeInitialization&quot;);</div><div class="line">        if(o instanceof Car)&#123;</div><div class="line">            ((Car)o).setName(&quot;bmw&quot;);</div><div class="line">            return o;</div><div class="line">        &#125;</div><div class="line">        return o;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object postProcessAfterInitialization(Object o, String s) throws BeansException &#123;</div><div class="line">        System.out.println(&quot;postProcessAfterInitialization&quot;);</div><div class="line">        return o;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着在配置文件中配置，不需要id属性，spring会自动识别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;con.qxg.bean.MyBeanPostProcess&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>main方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Car car = (Car) ctx.getBean(&quot;car2&quot;);</div><div class="line">System.out.println(car);</div><div class="line"></div><div class="line">ctx.close();</div></pre></td></tr></table></figure></p>
<p>打印日志为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">postProcessBeforeInitialization</div><div class="line">init</div><div class="line">postProcessAfterInitialization</div><div class="line">[bmw,846]</div><div class="line">destroy</div></pre></td></tr></table></figure>
<p>可以看到，其创建Car的bean对象的时候，会先调用后置处理器的postProcessBeforeInitialization方法，来进行处理，然后再调用Car的初始化方法，接着再调用后置处理器的postProcessAfterInitialization方法来处理。</p>
<p>方法中传入的对象，第一个就是要取得的bean对象，第二个就是bean的id值。</p>
<h1 id="通过工厂方法配置Bean"><a href="#通过工厂方法配置Bean" class="headerlink" title="通过工厂方法配置Bean"></a>通过工厂方法配置Bean</h1><h2 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h2><p>调用某个类的静态方法返回实例，就是静态工厂方法.</p>
<p>比如下列静态工厂方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class CarFactory &#123;</div><div class="line">    private static Map&lt;String,Car&gt; cars;</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        cars = new HashMap&lt;&gt;();</div><div class="line">        cars.put(&quot;bmw&quot;,new Car(&quot;bmw&quot;));</div><div class="line">        cars.put(&quot;ford&quot;,new Car(&quot;ford&quot;));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Car getCar(String name)&#123;</div><div class="line">        return cars.get(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么如何配置bean呢，注意配置bean并不是配置CarFactory：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;car&quot; class=&quot;con.qxg.factory.CarFactory&quot; factory-method=&quot;getCar&quot;&gt;</div><div class="line">    &lt;constructor-arg value=&quot;bmw&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>class制定工厂类，同时使用factory-method指定工厂方法。<br>其中constructor-arg表示的是传入的foctory-method中的参数，注意一定要使用constructor-arg来指定。</p>
<h2 id="实例工厂方法"><a href="#实例工厂方法" class="headerlink" title="实例工厂方法"></a>实例工厂方法</h2><p>实例工厂方法就是先创建实例，然后通过实例的方法来取得某bean对象，不举例子了，直接看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;!--先配置工厂实例--&gt;</div><div class="line">&lt;bean id=&quot;factory&quot; class=&quot;com.qxg.factory.InstanceCarFactory&quot;/&gt;</div><div class="line"></div><div class="line">&lt;!--通过factory-bean制定工厂实例，通过factory-method制定工厂方法，该方法不必是静态的。--&gt;</div><div class="line">&lt;bean id=&quot;car&quot; factory-bean=&quot;factory&quot; factory-method=&quot;getCar&quot;&gt;</div><div class="line">    &lt;constructor-arg value=&quot;ford&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<h1 id="通过FactoryBean配置bean"><a href="#通过FactoryBean配置bean" class="headerlink" title="通过FactoryBean配置bean"></a>通过FactoryBean配置bean</h1><p>创建类实现FactoryBean接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class CarFactoryBean implements FactoryBean &#123;</div><div class="line"></div><div class="line">    private String name;</div><div class="line"></div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //返回bean对象</div><div class="line">    @Override</div><div class="line">    public Object getObject() throws Exception &#123;</div><div class="line">        Car car = new Car();</div><div class="line">        car.setName(name);</div><div class="line">        return car;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    //返回对象类型</div><div class="line">    @Override</div><div class="line">    public Class&lt;?&gt; getObjectType() &#123;</div><div class="line">        return Car.class;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //是否是单例</div><div class="line">    @Override</div><div class="line">    public boolean isSingleton() &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么bean的配置就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;car&quot; class=&quot;con.qxg.factory.CarFactoryBean&quot;&gt;</div><div class="line">    &lt;property name=&quot;name&quot; value=&quot;tmp&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>虽然class指定了CarFactoryBean,但是实际返回的是该类中的getObject返回的对象。</p>
<h1 id="基于注解的方式配置bean"><a href="#基于注解的方式配置bean" class="headerlink" title="基于注解的方式配置bean"></a>基于注解的方式配置bean</h1><p>使用注解来配置bean，那么spring会进行扫描，如何扫描某文件中的bean呢？</p>
<p>是通过<context:component-scan>来指定扫描的目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;context:component-scan base-package=&quot;com.qxg.annotation&quot;/&gt;</div></pre></td></tr></table></figure></context:component-scan></p>
<p>这样就指定只扫描com.qxg.annotation包以及子包中的bean类了。</p>
<p>那么spring扫描类的时候，如何知道该类就是bean呢？</p>
<p>这个时候就需要注解，注解一共分为以下四种：</p>
<ul>
<li>@Component :基本注解，标示一个受Spring管理的组件</li>
<li>@Respository：标示持久层组件</li>
<li>@Service:标示服务层组件</li>
<li>@Controller:标示表现层组件</li>
</ul>
<p>不管注解是什么名字，只要类被以上注解标示，都会被Spring扫描到。</p>
<p>扫描到后，就可以通过getBean方法来取得。</p>
<p>但是getBean中如何传名字呢？通常是将类名第一个字母小写传入即可。</p>
<p>比如class Test,那么传入的参数就是”test”。</p>
<p>如果想要指定名字，可以在注解中指定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@Controller(value = &quot;myTest&quot;)</div></pre></td></tr></table></figure>
<p>这样取得bean的方法就是getBean(“myTest”);</p>
<h2 id="resource-pattern"><a href="#resource-pattern" class="headerlink" title="resource-pattern"></a>resource-pattern</h2><p>该属性是context:component-scan中的属性，意义为资源匹配，或者叫过滤，配置这个属性后，只会扫描与该属性匹配的类，如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;context:component-scan base-package=&quot;con.qxg.annotation&quot; resource-pattern=&quot;pattern/*.class&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>可以看到resource-pattern的值是 pattern/*.class，意思是只会扫描pattern子包中的类文件，其他包中的类文件不会被扫描。</p>
<h2 id="或"><a href="#或" class="headerlink" title=" 或 "></a><context:include-filter> 或 <context:exclude-filter></context:exclude-filter></context:include-filter></h2><p>这两个标签，也是用于过滤，第一个是包含哪些文件，第二个指定不包含哪些文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;context:component-scan base-package=&quot;con.qxg.annotation&quot; use-default-filters=&quot;false&quot;&gt;</div><div class="line">    &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;</div><div class="line">&lt;/context:component-scan&gt;</div></pre></td></tr></table></figure>
<p>对于include，必须要指定use-default-filters的值为false，否则不但include标签下类文件被扫描，base-package中的类文件也被扫描。</p>
<p>context:include-filter下的type指定类型，如上指定的是annotation，那么就会扫描注解类型，然后expression指定注解名称，注意是包全名。这样编写后，只会扫描con.qxg.annotation下的被@Controller注解的类。</p>
<p>对于<context:exclude-filter>就简单多了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;context:component-scan base-package=&quot;con.qxg.annotation&quot;&gt;</div><div class="line">    &lt;context:exclude-filter  type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;</div><div class="line">&lt;/context:component-scan&gt;</div></pre></td></tr></table></figure></context:exclude-filter></p>
<p>不需设置use-default-filters的值，这个标签只是排除某些类不被扫描。</p>
<h2 id="bean之间的关联关系"><a href="#bean之间的关联关系" class="headerlink" title="bean之间的关联关系"></a>bean之间的关联关系</h2><p>比如Person类中有Car的引用，使用注解分别注解了Person类和Car类，那么通过getBean方法取得Person的一个实例后，该实例中并不会包含Car的对象。</p>
<p>如何解决这个问题？</p>
<p><context:component-scan>元素会自动注册AutowiredAnnotationBeanPostProcessor实例，该实例可以自动装配@Autowired（常用）,@Resource,@Inject注解的属性。</context:component-scan></p>
<p>比如：</p>
<p>Person:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">@Controller</div><div class="line">public class Person &#123;</div><div class="line">    </div><div class="line">    private Car car;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line"></div><div class="line">    public Person()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setAge(int age) &#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCar(Car car) &#123;</div><div class="line">        this.car = car;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Car getCar() &#123;</div><div class="line">        return car;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void say()&#123;</div><div class="line">        System.out.println(&quot;My car is &quot; + car.toString());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Car:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@Controller</div><div class="line">public class Car &#123;</div><div class="line"></div><div class="line">    private String name;</div><div class="line">    private int size;</div><div class="line"></div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setSize(int size) &#123;</div><div class="line">        this.size = size;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;[&quot; + name + &quot;,&quot; + size + &quot;]&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了方便起见，将两个类的注解都设为@Controller。</p>
<p>接下来配置配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;context:component-scan base-package=&quot;con.qxg.bean&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>这样spring就会自动扫描到Person,Car类了。</p>
<p>然后main方法中测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Person p = (Person) ctx.getBean(&quot;person&quot;);</div><div class="line">p.say();</div></pre></td></tr></table></figure></p>
<p>然后就抛出异常：</p>
<blockquote>
<p>Exception in thread “main” java.lang.NullPointerException</p>
</blockquote>
<p>原因就是，Person中Car对象没有被装配，那么如何被装配呢</p>
<p>在Person中的代码中配置@Autowired</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Autowired</div><div class="line">private Car car;</div></pre></td></tr></table></figure>
<p>这样就能正常运行了，@Autowired会自动装配兼容类型的对象，其从IOC中取出对象装配进去。如果IOC中没有Car对象，就无法装配，编译时就会出现异常。</p>
<p>那么如果不希望Spring为Person装配，就可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Autowired(required = false)</div><div class="line">private Car car;</div></pre></td></tr></table></figure></p>
<p>这样就不会为其装配了，编译正常，不过car为null。</p>
<p>但是有一点值得注意，使用@Autowired标记的类对象，如果有两个类都是该类型，会匹配哪个呢？</p>
<p>比如@Autowired标记了一个接口类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Autowired </div><div class="line">private Animal animal;</div></pre></td></tr></table></figure></p>
<p>而被扫描的bean中有两个实现了Animal接口，一个是Dog，一个是Cat，那么装配的应该是哪个呢？</p>
<p>一般情况下，其装配是名为animal的bean，即与属性名一致的bean,这个名可以通过注解指定。比如@Controller(value = “animal”),而如果没有这个名的bean时候，就会抛出异常。</p>
<p>还有一种解决方法是，在装配的时候指定名字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Autowired</div><div class="line">@Qualifier(&quot;dog&quot;)</div><div class="line">private Animal animal;</div></pre></td></tr></table></figure></p>
<p>这样就会自动查找名为dog的bean对象，然后装配进去。</p>
<p>值得注意的是：<br>如果@Autowired放在数组上，集合上，那么Spring会把所有匹配的对象装载进去。</p>
<h1 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP(面向切面编程)"></a>AOP(面向切面编程)</h1><p>首先来看一个简单的问题，如果对于一段程序，我想在执行前，插入一段程序，在执行之后，再插入一段程序，按照正常思维模式，就是直接在源代码上编写就好了。但是如果对于每个方法，我都要求这样做，那么改源码的代价就非常昂贵了。</p>
<p>解决这个问题的方法就是动态代理，其思想是使用代理对象，包括住要修改的对象。</p>
<p>假设有这么一个对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Caculator &#123;</div><div class="line"></div><div class="line">    public int add(int a, int b)&#123;</div><div class="line">        System.out.println(&quot;add&quot;);</div><div class="line"></div><div class="line">        return a+b;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为简单起见，就写了一个方法，方法有返回值，返回a+b的值。</p>
<p>如果想要在打印前执行某操作，并在打印后执行另一个操作，手下要使用代理类实例化一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//第一个参数是由哪个类加载器加载，通常情况下和被加载的对象使用一样的类加载器，使用obj.getClass().getClassLoader()</div><div class="line">//第二个参数是Class数组，表示由动态代理产生的对象必须要实现的接口，注意必须是接口！！</div><div class="line">//第三个参数表示，当具体调用代理对象的方法时，将产生什么行为。</div><div class="line">Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</div></pre></td></tr></table></figure>
<p>比如针对Caculator的代理对象，如果要通过Caculator生成代理对象，必须要为其实现接口，因为代理对象返回的值就是接口中的某一个接口型对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//首先是接口：</div><div class="line">public interface Tmp &#123;</div><div class="line">    public int add(int a,int b);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//接着是Caculator：</div><div class="line">public class Caculator implements Tmp&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int add(int a, int b)&#123;</div><div class="line">        System.out.println(&quot;add&quot;);</div><div class="line"></div><div class="line">        return a+b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">//最后是生成代理对象的方法:</div><div class="line"> Tmp proxy = (Tmp) Proxy.newProxyInstance(Caculator.class.getClassLoader(), new Class[]&#123;Tmp.class&#125;,</div><div class="line">                new InvocationHandler() &#123;</div><div class="line">                    @Override</div><div class="line">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</div><div class="line">                        System.out.println(&quot;invoke&quot;);</div><div class="line">                        return 0;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure></p>
<p>可以看到，其中第一个参数就是要使用代理的类的加载器，第二个是接口的数组，数组内必须是接口，第三个就是Handler，用来处理事务。</p>
<p>注意看，在Caculator的add方法中打印了一条语句，输出”add”，并返回a+b，而在创建代理对象的第三个参数Handler中的invoke方法，打印的是”invoke”，返回的0。</p>
<p>那么此时做测试 ,proxy.add(1,2); 应该会打印”add”，并返回3。但是实际情况是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">invoke</div><div class="line">0</div></pre></td></tr></table></figure>
<p>也就是说，其执行的方法是invoke()，并没有执行add()方法。</p>
<p>那么如何执行原方法呢？</p>
<p>原方法就是在invoke()中使用反射去执行，invoke()中传入的参数是代理对象，原方法，以及原参数，还缺一个原对象，那么原对象应该写在哪呢？这个时候，原对象就应该new一个，所以最终的代码应该如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">final Caculator target = new Caculator();</div><div class="line"></div><div class="line">Tmp proxy = (Tmp) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),</div><div class="line">        new InvocationHandler() &#123;</div><div class="line">            @Override</div><div class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</div><div class="line">                System.out.println(&quot;invoke&quot;);</div><div class="line">                int result = method.invoke(target,args);</div><div class="line">                return result;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">int result = proxy.add(1,2);</div><div class="line">System.out.println(result);</div><div class="line"></div><div class="line">//注意其中第二个参数也可以通过target.getClass().getInterfaces()来获取。使用这个前提就是，代理对象不需要使用其他接口。</div></pre></td></tr></table></figure>
<p>这样在调用InvocationHandler()中的invoke方法中，先打印语句，然后调用原方法，最后才有返回值，那么在这个方法中，我可以随便操作原方法，我可以在原方法前执行某段代码，也可以在之后执行某段代码，甚至可以修改其返回值。只要通过proxy这个对象去执行的任意方法，都会只调用InvocationHandler中的invoke方法，这点要注意。</p>
<p>那么这就是动态代理。</p>
<p>那么对于AOP来讲，可以实现AOP的方式就是动态代理。</p>
<p>AOP是Aspect Oriented Programming的缩写。按照马士兵老师的说法就是，本来程序是一条线执行的，而面向切面变成就是在这条线上的某处切了一刀，执行我自己的操作，然后继续顺着这条线执行。</p>
<h2 id="Spring使用AOP"><a href="#Spring使用AOP" class="headerlink" title="Spring使用AOP"></a>Spring使用AOP</h2><ol>
<li>导包：aspectjweaver.jar</li>
<li><p>配置spring配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!--自动为匹配的类生成代理对象--&gt;</div><div class="line">&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>创建目标类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public class UserDao implements User &#123;</div><div class="line">    @Override</div><div class="line">    public void method() &#123;</div><div class="line">        System.out.println(&quot;UserDao method run&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>创建切面类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//@Aspect表示该类是一个切面类</div><div class="line">@Aspect</div><div class="line">@Component</div><div class="line">public class UserAspect &#123;</div><div class="line"></div><div class="line">    //@Before表示该方法会在某个类的方法前执行</div><div class="line">    //在execution中，可以通过*来匹配任意方法，任意包等</div><div class="line">    //也可以在该方法中加上JoinPoint类对象，来获取链接时候的细节。</div><div class="line">    @Before(&quot;execution(public void con.qxg.TestAOP.User.method())&quot;)</div><div class="line">    public void beforeMethod()&#123;</div><div class="line">        System.out.println(&quot;before&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</div><div class="line">//这个地方取得userDao，返回的并不是UserDao类型，而是Proxy类型，即代理对象，所以不能强转为UserDao类型，因为返回的代理对象只能是接口类型，而UserDao只实现了User接口，所以只能是User类型，一定要注意！</div><div class="line">User dao = (User) ctx.getBean(&quot;userDao&quot;);</div><div class="line">dao.method();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>打印结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">before</div><div class="line">UserDao method run</div></pre></td></tr></table></figure></p>
<h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>在前边的示例中，@Before就是标记的前置通知，意义是在方法执行前执行前置通知，当然也有后置通知：@After标记的方法。</p>
<p>后置通知的意义是在方法执行之后执行后置通知，无论是否发生异常。但是后置通知无法取得目标方法的结果。</p>
<p>如果要获取目标方法的结果，需要在返回通知里搞（@AfterReturning）,如何取得返回结果，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@AfterReturning(value = &quot;execution(public boolean con.qxg.TestAOP.User.method())&quot;,returning = &quot;result&quot;)</div><div class="line">public void afterReturning(boolean result)&#123;</div><div class="line">    System.out.println(&quot;afterReturning,result is &quot; + result);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>即通过注解中的returning的属性值来指定返回结果的变量名，而返回的类型在execution中已指明，所以以上代码应该很容易理解。</p>
<p>还有一个通知是异常通知，这个就是出现异常的时候会执行的通知@AfterThrowing，这个就不举例了。</p>
<p>通知中最强的一个就是@Around，环绕通知，但并不意味着这个通知是常用的。</p>
<p>其需要携带ProceedingJoinPoint类型的参数，且有返回值，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Around(&quot;execution(public boolean con.qxg.TestAOP.User.method())&quot;)</div><div class="line">public boolean around(ProceedingJoinPoint proceedingJoinPoint)&#123;</div><div class="line">    System.out.println(&quot;aroud&quot;);</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，该类型通知，必须携带ProceedingJoinPoint参数，并且如果目标方法有返回值，这个也必须有返回值，否则运行会出异常。<br>那么以上的环绕通知，会打印什么日志呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">aroud</div><div class="line">after</div><div class="line">afterReturning,result is true</div></pre></td></tr></table></figure></p>
<p>可以看，目标方法并没有执行，而是直接执行环绕通知，后续执行后置通知和返回通知。</p>
<p>这就应该明白了，环绕通知可以决定目标方法是否会被执行，并能决定返回值是什么。那么如何让目标方法恢复执行？</p>
<p>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Around(&quot;execution(public boolean con.qxg.TestAOP.User.method())&quot;)</div><div class="line">public boolean around(ProceedingJoinPoint proceedingJoinPoint)&#123;</div><div class="line">    System.out.println(&quot;aroud&quot;);</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        proceedingJoinPoint.proceed();</div><div class="line">    &#125; catch (Throwable throwable) &#123;</div><div class="line">        throwable.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>即使用ProceedingJoinPoint对象的proceed()方法即可恢复执行。恢复执行同样会执行前置通知。</p>
<h3 id="切面优先级"><a href="#切面优先级" class="headerlink" title="切面优先级"></a>切面优先级</h3><p>既然通过注解来为某个类的方法引入切面，那么如果有两个切面，执行顺序应该是什么呢？<br>这就涉及到切面的优先级了。</p>
<p>如何设置切面优先级呢？通过<code>@Order(1)</code>，值越小，优先级越高</p>
<h3 id="重用切点"><a href="#重用切点" class="headerlink" title="重用切点"></a>重用切点</h3><p>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@After(&quot;execution(public boolean con.qxg.TestAOP.User.method())&quot;)</div></pre></td></tr></table></figure></p>
<p>这个方法中的值是 <code>execution(public boolean con.qxg.TestAOP.User.method())</code>，那么我好多地方都会用到这个值，如何重用呢？</p>
<p>方法是定义一个方法，用于声明切入点表达式，方法中不需加其他代码，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Pointcut(&quot;execution(public boolean con.qxg.TestAOP.User.method())&quot;)</div><div class="line"> public void express()&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>那么对于@Before等通知的值传入方式就是<code>@Before(&quot;express()&quot;)</code>.<br>但是如果在其他类中定义的，前面就要加入类的名称，如:<code>@Before(&quot;User.express()&quot;)</code></p>
<h3 id="基于配置文件的AOP"><a href="#基于配置文件的AOP" class="headerlink" title="基于配置文件的AOP"></a>基于配置文件的AOP</h3><ol>
<li>配置bean</li>
<li>配置AOP</li>
</ol>
<p>如以下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;bean class=&quot;con.qxg.TestAOP.UserAspect&quot; id=&quot;userAspect&quot;/&gt;</div><div class="line">&lt;bean class=&quot;con.qxg.TestAOP.UserDao&quot; id=&quot;userDao&quot;/&gt;</div><div class="line"></div><div class="line">&lt;!-- AOP配置--&gt;</div><div class="line">&lt;aop:config&gt;</div><div class="line">    &lt;!--配置切点--&gt;</div><div class="line">    &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(public boolean con.qxg.TestAOP.User.method())&quot;/&gt;</div><div class="line">    &lt;!--配置切面--&gt;</div><div class="line">    &lt;aop:aspect ref=&quot;userAspect&quot;&gt;</div><div class="line">        &lt;aop:before method=&quot;beforeMethod&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</div><div class="line">    &lt;/aop:aspect&gt;</div><div class="line">&lt;/aop:config&gt;</div></pre></td></tr></table></figure></p>
<p>可以看到AOP配置中包含了 切点和切面，其实切点也可以省略，在切面中使用pointcut直接配置。</p>
<p>注意看，切面的几个要素：切面引用，切面通知，切面的切点引用。</p>
<h1 id="Spring的事务"><a href="#Spring的事务" class="headerlink" title="Spring的事务"></a>Spring的事务</h1><p>首先说明什么是事务，事务指的是对于一套代码，要么这些代码都成功执行，要么都不执行，这就是事务。</p>
<p>比如下面这行伪伪伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">buyBook(); //购买书，已出钱，数据库总金额改变</div><div class="line">outBook(); //书库出书，数据库中书个数-1</div></pre></td></tr></table></figure>
<p>对于上面一套逻辑，必须要用事务，如果不使用事务，假设buyBook()成功运行，而outBook()抛异常，这个时候用户只是出钱，而没有得到书，就很容易出现问题。</p>
<p>而Spring中的事务相当好使</p>
<p>直接一套配置 + 一个注解即可完成</p>
<p>假设以上代码在一个类的方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void method()&#123;</div><div class="line">    buyBook();</div><div class="line">    outBook();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先在配置文件中配置以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!--配置事务管理器--&gt;</div><div class="line">&lt;bean id=&quot;transactionManager&quot;</div><div class="line">      class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</div><div class="line">    &lt;!--配置dataSource--&gt;</div><div class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;!--启用事务注解--&gt;</div><div class="line">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>其中dataSource的配置在前面已经说过，这里再贴出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!--导入资源文件--&gt;</div><div class="line">&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</div><div class="line">&lt;!--配置dataSource--&gt;</div><div class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</div><div class="line">    &lt;property name=&quot;user&quot; value=&quot;$&#123;user&#125;&quot;&gt;&lt;/property&gt;</div><div class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;&gt;&lt;/property&gt;</div><div class="line">    &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;driverClass&#125;&quot;&gt;&lt;/property&gt;</div><div class="line">    &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbcUrl&#125;&quot;&gt;&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>最后就是一个注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Transactional</div><div class="line">public void method()&#123;</div><div class="line">    buyBook();</div><div class="line">    outBook();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个时候运行这个方法购买书的时候，不论哪个地方抛异常，所有的数据库的操作都不会成功，这就对应了事务的概念，要么都执行，要么都不执行。</p>
<h2 id="事务传播"><a href="#事务传播" class="headerlink" title="事务传播"></a>事务传播</h2><p>当一个事务被另一个事务调用时，要指定事务的传播行为。</p>
<p>Spring中指定7个传播行为，常用的2个，如下</p>
<ul>
<li>REQURED(默认) 如果有事务在运行，当前的方法就在这个事务中运行</li>
<li>REQURES_NEW当前方法必须开启一个新事务，如果有事务正在运行，应该将它挂起</li>
</ul>
<p>默认REQURED是什么样子的呢？</p>
<p>比如以下的一个事务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Transactional</div><div class="line">public void buyBook()&#123;</div><div class="line">    buyJavaBook();</div><div class="line">    buyC艹Book();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中buyJavaBook()和buyC艹Book()均有事务注解，默认的REQURED，假设buyJavaBook()成功执行，buyC艹Book()抛出异常，那么两本书，是否都被购买了呢？</p>
<p>如果是默认的REQURED，两本书都不会成功，因为这俩方法使用的是当前的事务，也就是buyBook()的事务，不论哪个方法中抛出异常，整个过程都不会执行，所以C艹没购买成功，那么Java也不会购买成功。</p>
<p>而对于REQURED_NEW就不同，比如buyJavaBook,buyC艹Book的注解为:<code>@Transactional(propagation = Propagation.REQUIRES_NEW)</code>,那么在buyJavaBook()开始的时候，会新开一个事务，不论这个方法是否执行成功，都不会影响buyC艹Book()的结果，也就是说这两个方法都会新开事务，互不影响，也不影响buyBook()这个方法。其实也可以简单理解为buyBook()这个事务，并不会搭理buyJavaBook()和buyC艹Book(）</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>使用isolation来指定，如<code>@Transactional(propagation = Propagation.REQUIRES_NEW,isolation = Isolation.READ_COMMITTED)</code></p>
<h2 id="noRollbackFor"><a href="#noRollbackFor" class="headerlink" title="noRollbackFor"></a>noRollbackFor</h2><p>表示对某异常不进行回滚,如<code>@Transactional(noRollbackFor = Exception.class)</code></p>
<h2 id="readOnly"><a href="#readOnly" class="headerlink" title="readOnly"></a>readOnly</h2><p>表示是否是只读事务，如果是，仅对数据库读操作不能写：<code>@Transactional(readOnly = true)</code></p>
<h2 id="timeOut"><a href="#timeOut" class="headerlink" title="timeOut"></a>timeOut</h2><p>表示事务运行多长时间后要强制回滚，<code>@Transactional(timeout = 4)</code>,表示事务如果运行超过4s就进行强制回滚</p>
<h2 id="基于xml配置事务"><a href="#基于xml配置事务" class="headerlink" title="基于xml配置事务"></a>基于xml配置事务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;!--配置事务管理器--&gt;</div><div class="line">&lt;bean id=&quot;transactionManager&quot;</div><div class="line">      class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</div><div class="line">    &lt;!--配置dataSource--&gt;</div><div class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;!--配置事务属性--&gt;</div><div class="line">&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</div><div class="line">    &lt;tx:attributes&gt;</div><div class="line">        &lt;!--根据方法名指定事务属性--&gt;</div><div class="line">        &lt;tx:method name=&quot;get*&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;</div><div class="line">        &lt;tx:method name=&quot;set*&quot; read-only=&quot;true&quot;/&gt;</div><div class="line">    &lt;/tx:attributes&gt;</div><div class="line">&lt;/tx:advice&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;!--配置事务切入点，并关联事务属性--&gt;</div><div class="line">&lt;aop:config&gt;</div><div class="line">    &lt;!--配置事务切入点--&gt;</div><div class="line">    &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* boolean con.qxg.TestAOP.User.*())&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;!--关联事务切入点和事务属性--&gt;</div><div class="line">    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;</div><div class="line">&lt;/aop:config&gt;</div></pre></td></tr></table></figure>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>spring配置不单单局限于xml和注解,还可以通过类来进行配置,可以上网搜对应的资料如JavaConfig,Groovy DSL等.这些配置都和Spring中的一些ApplicationContext相关,比如JavaConfig的配置和AnnotationConfigApplicationContext相关,而Groovy DSL则和GenericGroovyApplicationContext相关.</p>
<p>在Spring启动的时候,会进行一系列的操作,对于加载资源来说,spring需要的类有<code>Resource</code>,<code>ResouceLoader</code>,其中<code>ResourceLoader</code>就是用于加载资源<code>Resource</code>的,比如配置的加载路径是:<code>classpath:xxx.xxx.xxx</code>,ResourceLoader就可以通过该路径去加载对应的资源.</p>
<p>和Java中的Class类很相似,在Java中,每一个对象都有对应的Class类,在Spring中,每一个bean都有对应的配置类,就是<code>BeanDefinition</code>其保存bean的一系列配置信息,如<code>scope</code>,<code>lazy-init</code>等,<code>BeanDefinition</code>是一个接口,其抽象实现类是<code>AbstractBeanDefinition</code>,有两个类继承于该类,分别是<code>ChildBeanDefinition</code>,<code>RootBeanDefinition</code>就是这两个类,构成了Bean中的父子关系.在Spring启动的时候,会将xml或者其他配置文件中配置的bean,转换为<code>BeanDefinition</code>,并将<code>BeanDefinition</code>注册到<code>BeanDefinitionRegistry</code>中,<code>BeanDefinitionRegistry</code>就像spring的内存数据库,后续的操作直接从<code>BeanDefinitionRegistry</code>中读取配置信息.一般情况下,<code>BeanDefinition</code>只在容器启动的时候加载并解析,除非容器刷新或重启,否则这些信息是不会变化的.</p>
<p>创建最终的<code>BeanDefinition</code>主要包括两个步骤:</p>
<ol>
<li>利用<code>BeanDefinitionReader</code>读取承载配置信息的<code>Resource</code>,简单为每个<code>bean</code>生成对应的<code>BeanDefinition</code>,这里的<code>BeanDefinition</code>是半成品</li>
<li>利用<code>BeanFactoryPostProcessor</code>对半成品的<code>BeanDefinition</code>进行加工处理,此时<code>BeanDefinition</code>为成品.</li>
</ol>
<p>在生成BeanDefinition后,<code>InstantiationStrategy</code>负责通过<code>BeanDefinition</code>创建一个Bean实例.<code>InstantiationStrategy</code>是一个决策接口,其实现类可以通过不同的决策来实例化对应的类.最常用的实例化决策类是:<code>SimpleInstantiationStrategy</code>,该决策利用Bean实现类的默认构造函数,带参构造函数或工厂方法创建bean的实例.</p>
<p>但是<code>InstantiationStrategy</code>只是实例化对象,不会对对象进行set填充操作,所以实例化的对象是一个半成品对象,而填充操作需要借助<code>BeanWrapper</code>来完成.</p>
<p>spring中的<code>BeanWrapper</code>不单单作为包裹类而存在,它还是属性访问器,以及属性编辑器.在填充bean的值时,要从<code>BeanDefinitionRegistry</code>中获取<code>BeanDefinition</code>,然后取得<code>PropertyValue</code>的信息,后通过属性编辑器对<code>PropertyValue</code>进行转换得到bean的属性值,最后注入值即可.</p>
<p>属性编辑器就是将一个字面量值正确转换为对应的int,double等正确数据类型,或者将来某一个字符串直接转换为一个对象,其转换操作就是通过属性编辑器来完成的.说的通俗点,属性编辑器就是一个类型转换器.</p>
<p>spring在<code>PropertyEditorRegistrySupport</code>中为常见的属性类型提供了默认的属性编辑器,该类中有两个保存属性编辑器的Map变量,分别是<code>defaultEditors</code>和<code>customEditors</code>,前者保存spring中默认的属性编辑器,而后者保存用户自定义的属性编辑器,看到这就明白了,用户可以自定义属性编辑器,那么如何使用?</p>
<p>在spring中大部分属性编辑器都直接扩展于<code>PropertyEditorSupport</code>类,那么我们也可以通过扩展该类来实现自定义属性编辑器,比如我想将来这个字面量<code>xuefulan,red,2018</code>转换为一个Car对象,那么自定义属性编辑器如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class CustomCarEditor extends PropertyEditorSupport&#123;</div><div class="line"></div><div class="line">	public void setAsText(String)&#123;</div><div class="line">		if(text == null || text.indexOf(&quot;,&quot; == -1)&#123;</div><div class="line">			throw new IllegalArgumentException(&quot;设置的字符串格式不正确&quot;);		</div><div class="line">		&#125;	</div><div class="line">		String[] infos = text.split(&quot;,&quot;);</div><div class="line">		Car car = new Car();</div><div class="line">		car.setName(infos[0]);</div><div class="line">		car.setColor(infos[1]);</div><div class="line">		car.setYear(infos[2]);</div><div class="line">		//调用父类的setValue设置转换后的属性对象</div><div class="line">		setValue(car);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有了自定义属性编辑器后,还要进行注册,前面已经说过<code>PropertyEditorRegistrySupport</code>中有一个Map用来存储自定义属性编辑器,那么可以通过配置文件进行注册:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;&gt;</div><div class="line">    &lt;property name=&quot;customEditors&quot;&gt;</div><div class="line">        &lt;map&gt;</div><div class="line">            &lt;entry key=&quot;&quot;com.qxg.bean.Car&quot; value=&quot;com.qxg.editor.CustomCarEditor&quot; /&gt;</div><div class="line">        &lt;/map&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>entry中的key为对哪种类型的类会采取value中的属性编辑器.</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/18/Failed-to-execute-aapt/" rel="next" title="Failed to execute aapt">
                <i class="fa fa-chevron-left"></i> Failed to execute aapt
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/02/20/effective-java/" rel="prev" title="effective java">
                effective java <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/02/19/spring学习/"
           data-title="spring学习" data-url="http://yoursite.com/2017/02/19/spring学习/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="QxG" />
          <p class="site-author-name" itemprop="name">QxG</p>
          <p class="site-description motion-element" itemprop="description">努力才会有机遇</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">52</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简单使用"><span class="nav-number">1.</span> <span class="nav-text">简单使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#配置bean"><span class="nav-number">2.</span> <span class="nav-text">配置bean</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#xml形式"><span class="nav-number">2.1.</span> <span class="nav-text">xml形式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bean的命名"><span class="nav-number">2.1.1.</span> <span class="nav-text">bean的命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constructor-arg"><span class="nav-number">2.1.2.</span> <span class="nav-text">constructor-arg</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#index"><span class="nav-number">2.1.3.</span> <span class="nav-text">index</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type"><span class="nav-number">2.1.4.</span> <span class="nav-text">type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CDATA"><span class="nav-number">2.1.5.</span> <span class="nav-text">![CDATA]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ref"><span class="nav-number">2.1.6.</span> <span class="nav-text">ref</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#"><span class="nav-number">2.1.7.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#级联属性"><span class="nav-number">2.1.8.</span> <span class="nav-text">级联属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合属性"><span class="nav-number">2.1.9.</span> <span class="nav-text">集合属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#props"><span class="nav-number">2.1.10.</span> <span class="nav-text">props</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#util"><span class="nav-number">2.1.11.</span> <span class="nav-text">util</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#p"><span class="nav-number">2.1.12.</span> <span class="nav-text">p</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c"><span class="nav-number">2.1.13.</span> <span class="nav-text">c</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动装配-不推荐使用"><span class="nav-number">2.1.14.</span> <span class="nav-text">自动装配(不推荐使用)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置中的继承"><span class="nav-number">2.1.15.</span> <span class="nav-text">配置中的继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置中的依赖"><span class="nav-number">2.1.16.</span> <span class="nav-text">配置中的依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bean的作用域"><span class="nav-number">2.1.17.</span> <span class="nav-text">bean的作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用外部属性文件"><span class="nav-number">2.1.18.</span> <span class="nav-text">使用外部属性文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用加密文件"><span class="nav-number">2.1.19.</span> <span class="nav-text">使用加密文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpEL"><span class="nav-number">3.</span> <span class="nav-text">SpEL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引用"><span class="nav-number">3.1.</span> <span class="nav-text">引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调用静态方法"><span class="nav-number">3.2.</span> <span class="nav-text">调用静态方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三目运算符"><span class="nav-number">3.3.</span> <span class="nav-text">三目运算符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bean生命周期"><span class="nav-number">4.</span> <span class="nav-text">Bean生命周期</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bean后置处理器"><span class="nav-number">5.</span> <span class="nav-text">bean后置处理器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#通过工厂方法配置Bean"><span class="nav-number">6.</span> <span class="nav-text">通过工厂方法配置Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#静态工厂方法"><span class="nav-number">6.1.</span> <span class="nav-text">静态工厂方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例工厂方法"><span class="nav-number">6.2.</span> <span class="nav-text">实例工厂方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#通过FactoryBean配置bean"><span class="nav-number">7.</span> <span class="nav-text">通过FactoryBean配置bean</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基于注解的方式配置bean"><span class="nav-number">8.</span> <span class="nav-text">基于注解的方式配置bean</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#resource-pattern"><span class="nav-number">8.1.</span> <span class="nav-text">resource-pattern</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#或"><span class="nav-number">8.2.</span> <span class="nav-text"> 或 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bean之间的关联关系"><span class="nav-number">8.3.</span> <span class="nav-text">bean之间的关联关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AOP-面向切面编程"><span class="nav-number">9.</span> <span class="nav-text">AOP(面向切面编程)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring使用AOP"><span class="nav-number">9.1.</span> <span class="nav-text">Spring使用AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通知"><span class="nav-number">9.1.1.</span> <span class="nav-text">通知</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#切面优先级"><span class="nav-number">9.1.2.</span> <span class="nav-text">切面优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重用切点"><span class="nav-number">9.1.3.</span> <span class="nav-text">重用切点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于配置文件的AOP"><span class="nav-number">9.1.4.</span> <span class="nav-text">基于配置文件的AOP</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring的事务"><span class="nav-number">10.</span> <span class="nav-text">Spring的事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#事务传播"><span class="nav-number">10.1.</span> <span class="nav-text">事务传播</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务隔离级别"><span class="nav-number">10.2.</span> <span class="nav-text">事务隔离级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#noRollbackFor"><span class="nav-number">10.3.</span> <span class="nav-text">noRollbackFor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#readOnly"><span class="nav-number">10.4.</span> <span class="nav-text">readOnly</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#timeOut"><span class="nav-number">10.5.</span> <span class="nav-text">timeOut</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于xml配置事务"><span class="nav-number">10.6.</span> <span class="nav-text">基于xml配置事务</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#后记"><span class="nav-number">11.</span> <span class="nav-text">后记</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QxG</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"qxgzone"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  

  

  

  

  


</body>
</html>
