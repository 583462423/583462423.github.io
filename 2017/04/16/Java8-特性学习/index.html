<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java8," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Java8新特性已经出了这么久,竟然还不会用,所以抽空学习下这个新特性.学习书籍是&amp;lt;&amp;gt;">
<meta property="og:type" content="article">
<meta property="og:title" content="Java8 特性学习">
<meta property="og:url" content="http://yoursite.com/2017/04/16/Java8-特性学习/index.html">
<meta property="og:site_name" content="Everything Changes">
<meta property="og:description" content="Java8新特性已经出了这么久,竟然还不会用,所以抽空学习下这个新特性.学习书籍是&amp;lt;&amp;gt;">
<meta property="og:updated_time" content="2017-04-22T09:50:58.752Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java8 特性学习">
<meta name="twitter:description" content="Java8新特性已经出了这么久,竟然还不会用,所以抽空学习下这个新特性.学习书籍是&amp;lt;&amp;gt;">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/04/16/Java8-特性学习/"/>





  <title>Java8 特性学习 | Everything Changes</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Everything Changes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/Java8-特性学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="QxG">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Everything Changes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java8 特性学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T23:55:42+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/16/Java8-特性学习/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/16/Java8-特性学习/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Java8新特性已经出了这么久,竟然还不会用,所以抽空学习下这个新特性.学习书籍是&lt;<java8中文>&gt;<br><a id="more"></a></java8中文></p>
<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>注意lambda而不是lamada = =.通过<code>()-&gt;{}</code>构成的表达式,()中传入参数,{}是方法体.</p>
<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Comparator c = new Comparator&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public int compare(Integer o1, Integer o2) &#123;</div><div class="line">                return Integer.compare(o1,o2);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>可以替换为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Integer&gt; c2 = (Integer o1, Integer o2)-&gt;o2.compareTo(o1);</div></pre></td></tr></table></figure></p>
<p>如果在IDEA中这样写,就会有提示,但不是差错,提示可以替换成下列操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Integer&gt; c2 = Comparator.naturalOrder();</div></pre></td></tr></table></figure></p>
<p>不过这里只是说明其用法.</p>
<ol>
<li><p>如果逻辑比较多,可以使用{}包裹:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Integer&gt; c2 = (Integer o1, Integer o2)-&gt;&#123;</div><div class="line">            if(o1 &lt; o2)return -1;</div><div class="line">            else return 1;</div><div class="line">        &#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>如果表达式中参数的类型可以被推到,那么类型可以被省略,如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Integer&gt; c2 = (o1,  o2)-&gt;&#123;</div><div class="line">            if(o1 &lt; o2)return -1;</div><div class="line">            else return 1;</div><div class="line">        &#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上边这个表达式,可以推导出o1,o2是Integer类型的,所以忽略了其类型.</p>
<ol>
<li>如果方法只有一个参数,且参数类型可以被推导,那么甚至可以省略小括号,如:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EventHandler e = new javafx.event.EventHandler() &#123;</div><div class="line">	@Override</div><div class="line">	public void handle(Event event) &#123;</div><div class="line">	    System.out.println(&quot;o&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>可以写为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventHandler e = event -&gt; System.out.println(&quot;e&quot;);</div></pre></td></tr></table></figure></p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>对于只包含一个抽象方法的接口,可以通过lambda表达式来创建该接口的对象,这种接口被称为函数式接口.</p>
<p>你可能奇怪函数式接口必须只有一个抽象方法,难道接口中方法不都是抽象的么?但是Comparator中不仅有抽象方法,还有Object中的一些方法,而这些方法并不是抽象的</p>
<p>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Integer&gt; c2 = (Integer o1, Integer o2)-&gt;o2.compareTo(o1);</div></pre></td></tr></table></figure></p>
<p>右部就是一个函数式接口.函数式接口的转换是你在Java中使用lambda表达式能做的唯一一件事.</p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.setAction(event-&gt;System.out.println(event));</div></pre></td></tr></table></figure>
<p>可以写为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.setAction(System.out::println);</div></pre></td></tr></table></figure></p>
<p>其中<code>System.out::println</code>就是一个方法引用,等同于<code>event-&gt;System.out.println(event)</code>.<br><code>::</code>操作符将方法名和对象或类的名字分隔开来,以下是三种主要的使用情况:</p>
<ul>
<li>对象::实例方法, 如:<code>System.out::println</code>等同于<code>x-&gt;System.out.println(x)</code>注意的是,这种情况,因为对象已经有了,所以参数只能传入方法中</li>
<li>类::静态方法,如:<code>Math::pow</code>等同于<code>(x,y)-&gt;Math.pow(x,y)</code>,注意这种情况也是,因为是静态方法,所以只能传给方法参数</li>
<li>类::实例方法,这个方式比较特殊,因为是类的实例方法,这个实例方法只能通过对象来调用,所以传入的第一个参数是作为类的实例存在的,如<code>String::compareTo</code>等同于<code>(x,y)-&gt;x.compareTo(y)</code>.</li>
</ul>
<p>对于<code>对象::实例方法</code>这个方式来说,对象可以传入<code>this</code>,<code>super</code>等,比如<code>this::equals</code>等同于<code>x-&gt;this.equals(x)</code>.如下示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Greeter&#123;</div><div class="line">	public void greet()&#123;</div><div class="line">		System.out.println(&quot;Hello,world!&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ConcurrentGreeter extends Greeter&#123;</div><div class="line"></div><div class="line">	public void greet()&#123;</div><div class="line">		Thread t = new Thread(super::greet);</div><div class="line">		t.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中创建线程的时候,传入的Runnable其方法会执行supre.greet()方法.<code>supre::greet</code>等同于<code>()-&gt;super.greet()</code>,又等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">new Runnable()&#123;</div><div class="line">	public void run()&#123;</div><div class="line">		super.greet();	</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><p><code>Button::new</code>相当于<code>new Button()</code>但是会调用哪个构造器,还是需要根据语境.<br><code>int[]::new</code>相当于<code>x-&gt;new int[x]</code>.</p>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>如果通过lambda表达式访问外部变量,其访问的变量在lambda中是不可以变化的.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void method(int count)&#123;</div><div class="line"></div><div class="line">	new Thread(()-&gt;&#123;</div><div class="line">		for(int i=0; i&lt;count; i++)&#123;</div><div class="line">			System.out.println(i);		</div><div class="line">		&#125;	</div><div class="line">	&#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上所示,代码是合法的,即使外部变量没有使用final修饰,如果要在代码中改变count的值,将会不合法.<br>但是对于Java内部类来说,其可以访问外部final修饰的变量,并且不能改变其值,但是有一种巧妙的办法可以改变值,就是声明一个长度为1的数组,比如:<code>int[] couter = new int[1]</code>,那么在内部类中,counter是final形的,但是counter[1]却可以改变.</p>
<p>lambda表达式的方法体与嵌套代码块有相同的作用域,lambda表达式中不允许声明与局部变量同名的参数,如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String first=&quot;aaa&quot;;</div><div class="line">Comparator&lt;String&gt; comp = (first,second)-&gt;Integer.compare(first.length(),second.length());</div></pre></td></tr></table></figure></p>
<p>以上代码是错误的,因为first已被定义了.</p>
<p>当在lambda表达式中使用this关键字时,你会创建该lambda表达式的方法的this参数,比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Application&#123;</div><div class="line">	public void doWork()&#123;</div><div class="line">		Runnable r = ()-&gt;&#123;</div><div class="line">			System.out.println(this.toString());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中this.toString()会调用Applicatoin对象的toString()方法,而不是Runnable实例的toString()方法.</p>
<h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>提供一个方法,用来将一个函数应用到集合的每个元素上,如:<br><code>list.forEach(System.out::println);</code><br>注意list是一个集合,顶层接口是Collection.在Java8中突然蹦出来了一个forEach方法,这样就使得每个实现了Collection接口的类都要重写forEach,这在Java中是无法被接受的,所以出现了默认方法这种东西.</p>
<p>对于接口中实现的默认方法,通过default进行修饰,比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">interface Person&#123;</div><div class="line">	long getId();</div><div class="line">	default String getName()&#123;return &quot;John Q. Public&quot;;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到默认方法是有实现的.那么实现Person接口的实现类,必须实现getId(),但是可以选择不实现getName().<br>如果某个类实现了两个接口,并且有同名的方法,其中一个是默认方法,另一个不论是否是默认方法,都会导致方法冲突,这个时候就需要使用覆盖来解决,即在该类中重写这个方法,在该方法中调用其中一个接口的方法,如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Student implements Person,Named&#123;</div><div class="line">	public String getName()&#123;</div><div class="line">		return Person.super.getName();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而如果继承了父类且实现了某个接口,父类和接口中出现方法冲突,会使用父类中方法,忽略接口中默认方法.</p>
<h2 id="接口中的静态方法"><a href="#接口中的静态方法" class="headerlink" title="接口中的静态方法"></a>接口中的静态方法</h2><p>Java8中,可以为接口添加静态方法.</p>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><h2 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h2><p>Java8在Collection接口中新添加Stream方法,可以将任何集合转化为一个Stream.如果是一个数组,可以用静态的Stream.of方法将它转化为一个Stream.<br>Stream.of方法接口可变长度的参数,如:<code>Stream&lt;String&gt; song = Stream.of(&quot;gently&quot;,&quot;down&quot;,&quot;the&quot;,&quot;stream&quot;);</code><br><code>Arrays.stream(array,from,to)</code>将数组的一部分转换为Stream.<br>要创建一个不含任何元素的Stream,使<code>Stream.empty方法</code>.<br><code>Stream.generate(()-&gt;&quot;echo&quot;)</code>用来创建无限个”echo”的Stream,但是注意,Stream执行到这的时候,并不会真正去创建无限个”echo”.<br><code>Stream.generate(Math::random)</code>等同于<code>Stream.generate(()-&gt;Math.random())</code>用来创建无限个随机数.<br><code>Stream&lt;BigInteger&gt; integers = Stream.iterate(BigInteger.ZERO,n-&gt;n.add(BigInteger.ONE))</code>用来创建0,1,2,3…的序列,第一参数是开头的数字,第二个表示后一个数和前一个数的关系,是个接口.</p>
<h2 id="filter-map和flatMap"><a href="#filter-map和flatMap" class="headerlink" title="filter,map和flatMap"></a>filter,map和flatMap</h2><p>filter方法的参数是一个Predicate<t>接口,返回boolean类型,比如过滤数组中比10大的数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Integer[] a = &#123;1,10,1,10,1,10&#125;;</div><div class="line">Stream&lt;Integer&gt; stream = Arrays.stream(a);</div><div class="line">stream.filter(n-&gt;n&gt;10);</div></pre></td></tr></table></figure></t></p>
<p>即filter方法是对stream进行过滤</p>
<p>map是对方法中的数据或类型进行转换,<br>比如将所有字符串转换为小写字母:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String[] s = &#123;&quot;ABC&quot;,&quot;EFG&quot;&#125;;</div><div class="line">Stream&lt;String&gt; stream = Arrays.stream(s);</div><div class="line">stream.map(String::toLowerCase);</div></pre></td></tr></table></figure></p>
<p><code>stream.map(String::toLowerCase);</code>等同于<code>stream.map(ss-&gt;ss.toLowCase())</code>.<br>将字符串转为第一个字符开头的字符数组:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream&lt;Character&gt; cs = stream.map(n-&gt;n.charAt(0));</div></pre></td></tr></table></figure></p>
<p>上面例子可以看到,map可以转换数据,以及数据类型.</p>
<p>flatMap方法是展开流,比如下面方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static Stream&lt;Character&gt; characterStream(String s)&#123;</div><div class="line">	List&lt;Character&gt; result = new ArrayList&lt;&gt;();</div><div class="line">	for(char c:s.toCharArray()) result.add(c);</div><div class="line">	return resutl.stream();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么对于上面的函数,characterStream(“boat”)返回的就是[‘b’,’o’,’a’,’t’]的流对象,但是下面的函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream&lt;Stream&lt;Character&gt;&gt; letters = stream.map(s-&gt;characterStream(w));</div></pre></td></tr></table></figure></p>
<p>这个流返回的就是一个包括多个流的流,因为map中是将每个字符串转换为对应的类型,原来的字符串数组在转换后,所有的字符串变成了流对象,那么最终获取的对象就是流数组.</p>
<p>有点绕口,比如stream是[“abc”,”efg”]这样的流对象,那么经过转换后变为[ [‘a’,’b’,’c’] , [‘e’,’f’,’g’] ]这样的流对象.该流对象中的包含多个其他流对象.<br>但是如果我想要将所得到的流对象进行展开,比如[“abc”,”efg”]中每个字符串都转换为数组后,进行展开,变成[‘a’,’b’,’c’,’e’,’f’,’g’]的样式,这样应该怎么操作,这个时候就用到了flagMap.<br>那么以上代码就应该改为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream&lt;Character&gt; letters = stream.flagMap(s.-&gt;characterStream(w));</div></pre></td></tr></table></figure></p>
<p>可以看出,flagMap是针对流对象,对每个流再进行展开操作.</p>
<h2 id="提取子流和组合流"><a href="#提取子流和组合流" class="headerlink" title="提取子流和组合流"></a>提取子流和组合流</h2><p>Stream.limit(n)会返回一个包含n个元素的新流(如果原始长度小于n,则返回原始流),这个方法适用于裁剪指定长度的流,比如之前的Stream.generate来生成随机数的流,其生成的流是无限的,那么裁剪成具体个数可以写为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream&lt;Double&gt; randoms = Stream.generate(Math::random).limit(100);</div></pre></td></tr></table></figure></p>
<p>Stream.skip(n)则会抛弃前面n个元素.注意和数组下标不同,skip(1)就表示抛弃第一个元素,即下标为0的元素,skip(0)不抛弃任何元素.</p>
<p>Stream.concat(stream1,stream2)将两个流对象合并,第一个流的长度不能是无限的,否则第二个流永远没机会添加到第一个流后面.</p>
<blockquote>
<p>peek方法会产生一个与原始流具有相同元素的流,但是每次获取一个元素时,都会调用一个函数,方便调试,如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Object[] powers = Stream.iterate(1,i-&gt;i*2)</div><div class="line">                .peek(e-&gt; System.out.println(e))</div><div class="line">                .limit(10).toArray();</div></pre></td></tr></table></figure></p>
</blockquote>
<p>在生成数组的时候,会将每个数进行打印.<br>这里有点要注意:<code>Stream.iterate(1,i-&gt;i*2).peek(e-&gt; System.out.println(e)).limit(10);</code>这样返回的流对象,是不会打印任何东西的,因为并没有生成数组,所以到这就应该明白,流对象中的内容并不是实际存在的.</p>
<h2 id="有状态的转换"><a href="#有状态的转换" class="headerlink" title="有状态的转换"></a>有状态的转换</h2><p>什么叫有状态的转换?在前面的流的操作都是无状态的转换,因为每转换一个对象,都不关心之前的对象是什么状态,而对于有状态的转换会记录前边的状态,比如要将一个数组返回一个无重复的数组,那么每返回一个数,都要关心前边的数中有没有相同的数,这就是有状态的转换.</p>
<p>Java8提供了有状态的转换,比如distinct方法会根据原始流中的元素返回一个具有相同顺序,但是无重复元素的新流,显然,该流必须记住之前的已读取的元素.<br>如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream&lt;String&gt; uniqueWords = Stream.of(&quot;lili&quot;,&quot;lili&quot;,&quot;lili&quot;).distinct();</div></pre></td></tr></table></figure></p>
<p>操作后只返回一个有<code>lili</code>的流对象.</p>
<p>当然流中也提供了排序方法.Java8中提供了多个sorted方法,其中一个用于其中元素实现了Comparable接口的流,另一个接受Comparator对象.其实跟Collections中的排序意义差不多.<br>比如第一种:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer[] i = &#123;1,2,3,4,5,6,7,8,9,10,2,3,4,5,6,7&#125;;</div><div class="line">Arrays.stream(i).sorted().peek(e-&gt; System.out.println(e)).toArray();</div></pre></td></tr></table></figure></p>
<p>不用传参数即可进行排序,其排序使用的是Integer默认的排序的规则.<br>而第二种方式,传入的是Comparator:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String[] s = &#123;&quot;aaa&quot;,&quot;bbbb&quot;,&quot;ccccc&quot;&#125;;</div><div class="line">Arrays.stream(s).sorted(Comparator.comparing(String::length).reverse());</div></pre></td></tr></table></figure></p>
<p>其中Comparator.comparing返回一个Comparator,reverse()同样返回一个Comparator.<br>还要注意一点,Collections.sort()方法是对原来的集合进行排序,而Stream.sort()是返回一个排序的流,对原始集合没有影响.</p>
<h2 id="简单的聚合方法"><a href="#简单的聚合方法" class="headerlink" title="简单的聚合方法"></a>简单的聚合方法</h2><p>聚合方法都是终止操作,当使用了终止操作后,就不能再应用其他操作了.这个不能有其他操作的意思不是在后边跟上.xxx()这样的操作,而是在以后的任何地方,都不能对stream有其他操作了<br>比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Stream&lt;Integer&gt; stream = Arrays.stream(i);</div><div class="line">boolean first = stream.anyMatch(j-&gt;j==5);</div><div class="line">Optional&lt;Integer&gt; o = stream.filter(j -&gt; j&gt;5).findFirst();</div></pre></td></tr></table></figure></p>
<p>这个代码将抛出异常,因为第二行已经使用聚合方法,所以第三行是不被允许的.</p>
<p>比如<code>count()</code>方法就是聚合方法,该方法用于返回流对象中元素的个数.<br>另外两个聚合方法是<code>max</code>和<code>min</code>,分别分会流中最大值和最小值,需要注意的是,这个方法会返回一个Optional<t>值,它可能会封装返回值,也可能表示没有返回(流为空).<br>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Optional&lt;Integer&gt; largest = stream.max(Integer::compareTo);</div><div class="line">if(largest.isPresent())&#123;</div><div class="line">    System.out.println(largest.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure></t></p>
<p><code>findFrist</code>用来返回非空集合中的第一个值,通常与filter方法结合起来用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Optional&lt;Integer&gt; first = stream.filter(j-&gt;j&gt;5).findFirst();</div></pre></td></tr></table></figure></p>
<p>而如果找到所有匹配的元素中符合条件的元素(而不是第一个),可以使用<code>findAny</code>方法,这个方法在并行的时候十分有效,因为只要在任何片段中发现了第一个匹配的元素都会结束整个计算.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Optional&lt;Integer&gt; first = stream.filter(j-&gt;j&gt;5).findAny();</div></pre></td></tr></table></figure></p>
<p>如果只希望知道流中是否含有匹配元素,可以使用<code>anyMatch()</code>方法,该方法接受一个Predicate接口参数,所以不需要使用filter方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boolean hasFive = stream.anyMatch(j-&gt;j==5);</div></pre></td></tr></table></figure></p>
<p>还有两个方法<code>allMatch</code>在所有元素匹配的时候返回true,<code>noneMatch</code>在没有元素匹配的时候返回true.虽然这些方法检查整个流,但是仍然可以通过并行的方法检查整个流.</p>
<h2 id="Optional类型"><a href="#Optional类型" class="headerlink" title="Optional类型"></a>Optional类型</h2><p>Optional<t>是对T类型对象的封装,不会返回null,如果存在被封装的对象,通过<code>get()</code>取得,否则会抛出NoSuchElementException.</t></p>
<p>可以看到Optional可能会抛出异常,所以高效的使用Optional的关键在于,使用一个或接受正确值,或者返回另一个替换值的方法.</p>
<p><code>ifPresent</code>方法表示,如果Optional中存在值,就将该值传递给某函数,注意不是<code>isPresent</code>方法.<br>ifPresent()方法的参数是一个Consumer接口,该接口唯一抽象方法是<code>accept</code>.比如下列代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Optional&lt;Integer&gt; o = stream.filter(j -&gt; j&gt;5).findFirst();</div><div class="line">o.ifPresent(s-&gt; System.out.println(s));</div></pre></td></tr></table></figure></p>
<p>该代码就是成功打印找到的第一个符合条件的数,但是如果o中的value是空,将不会有任何操作.</p>
<p>如果想要对结果进行处理,可以使用<code>map</code>方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Optional&lt;Boolean&gt; b = o.map(s-&gt;s==6);</div></pre></td></tr></table></figure></p>
<p>如果返回的结果就是map中的操作返回值,返回值也可以是其他类型.</p>
<p>如果所得的Optional没有值的时候,希望使用默认值替换,那么操作如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer result = o.orElse(5);</div></pre></td></tr></table></figure></p>
<p>如果o中不存在值的时候,返回5,否则返回o中的值.<br>也可以调用代码来设置默认值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer result = o.orElseGet(()-&gt;1+5);</div></pre></td></tr></table></figure></p>
<p>或者希望没有值的时候抛出异常:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">o.orElseThrow(RuntimeException::new);</div></pre></td></tr></table></figure></p>
<h3 id="创建可选值"><a href="#创建可选值" class="headerlink" title="创建可选值"></a>创建可选值</h3><p>前边是使用stream来获取的Optional对象,当然也可以通过Optional中的静态方法来获取Optional对象,<code>Optional.of(result)</code>或<code>Optional.empty()</code>用来创建一个Optional对象.而<code>Optional.ofNullable(obj)</code>会返回Optional.of(obj)而如果obj为空,则返回Optional.empty().</p>
<h3 id="使用flatMap来组合可选函数"><a href="#使用flatMap来组合可选函数" class="headerlink" title="使用flatMap来组合可选函数"></a>使用flatMap来组合可选函数</h3><p>加入有一个返回<code>Optional&lt;T&gt;</code>的方法<code>f()</code>,并且目标类型<code>T</code>中有一个会返回<code>Optional&lt;U&gt;</code>的方法g,如果它们是普通方法,那么可以通过f().g()这样的方式进行调用.但是这种组合在<code>Optional</code>形式中是行不通的,但可以通过<code>flatMap</code>方法来进行组合:<code>f().flatMap(T::g);</code><br>如果f()方法返回的<code>Optional&lt;T&gt;</code>不为空,那么就会调用T的g方法,而如果为空,则之间返回<code>Optional.empty()</code></p>
<p>通过<code>flatMap</code>就可以进行流失操作.但是理解起来比较困难.</p>
<h2 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h2><p>如果你希望对元素求和,可以使用一个二元函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Optional&lt;Integer&gt; sum = stream.reduce((x,y)-&gt;x+y);</div></pre></td></tr></table></figure></p>
<p>该代码含义就是对所有值求和,可以简单理解为((x+y) + y ) + y …,即使前两个元素相加后的结果变为x再与后边的元素相加.或者写为下列代码更容易理解:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Optional&lt;Integer&gt; sum = stream.reduce((result,element)-&gt;result+element);</div></pre></td></tr></table></figure></p>
<p>以上代码还可以改写为<code>stream.reduce(Integer::sum)</code></p>
<p>如果聚合方法有一个聚合操作<code>op</code>,那么该聚合会产生<code>v op v1 op v2 op ...</code>其中vi op vj 就是编写的函数调用<code>op(vi,vj)</code>,该操作应是联合的,与组合元素的顺序无关,在数学中,如果<code>(x op y) op z = x op (y op z)</code>,这样就允许通过并行流来进行有效的聚合.</p>
<p>通常如果<code>e op x = x</code>,那么就可以使用e作为计算的起点,比如相加操作,因为<code>0 + 1 = 1</code>,所以0就是起点,上述代码可以改为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer sum = stream.reduce(0,(x,y)-&gt;x+y); //即计算0 + v1 + v2 + v3 + v4的值</div></pre></td></tr></table></figure></p>
<p>当计算到最后的时候,返回标示值,也就是参数中的第一个,其是Integer类型,最终就会返回Integer类型的最终值.</p>
<p>但是如果注意看,reduce的这两个方法中,传入的值的类型都是一样的,即使传入的是<code>(T,T)-&gt;T</code>这种类型,但是如果我想要计算一个字符串流中字符个数的总和,传入<code>(String s1,String s2)-&gt;s1.length() + s2.length()</code>就会出错,这个时候就需要使用另一种聚合方法,首先提供一个累加函数,这个函数(T,R)-&gt;T,这个函数进行并行累加结果,最后将所有的结果再进行累加,如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int sum = stream.reduce(0,(total,word)-&gt;total+word.length(),(total1,total2)-&gt;total1+total2);</div></pre></td></tr></table></figure></p>
<p>第二个参数传入的就是累加函数,用于自己定义的一种累加方法,最后将这些累加的结果再次做累加即可取得结果.</p>
<p>前两个方法,是操作同一种类型的值,而第三个方法是可以操作不同类型的值,注意第三个方法中的第三个参数是用于处理并行下的运算结果的,如果是单线程,一般这个方法不会被调用,理解就好.</p>
<p>一般不会大量使用聚合方法,比如累加方法计算字符串的长度累加和,可以这样写:<code>stream.mapToInt(String::length).sum()</code>.</p>
<h2 id="收集结果"><a href="#收集结果" class="headerlink" title="收集结果"></a>收集结果</h2><p>处理完流后,可以调用toArray()方法来获取所有元素的数组,但是调动这个方法只能返回Object类型的数组,如果要范湖一个指定类型的数组,需要将来类型传递给toArray()方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String[] result = words.toArray(String::new);</div></pre></td></tr></table></figure></p>
<p>如果要收集结果到一个集合中,可以用collect方法,这个方法支持并行,所以其参数为:</p>
<ol>
<li>一个能创建目标类型的实例方法,如HashSet的构造函数</li>
<li>一个将元素添加到目标中的方法,如add方法</li>
<li>一个将两个对象整合到一起的方法,如addAll,用于并行.</li>
</ol>
<p>比如添加到HashSet中:<code>HashSet&lt;String&gt; result = stream.collect(HashSet::new,HashSet::add,HashSet:addAll);</code></p>
<p>但是实际中一般不会这么做,因为Collectors接口已提供了很多种方法,如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//收集到list中</div><div class="line">List&lt;String&gt; result = stream.collect(Collectors.toList());</div><div class="line"></div><div class="line">//set中</div><div class="line">Set&lt;String&gt; result = stream.collect(Collectors.toSet());</div><div class="line"></div><div class="line">//TreeSet中</div><div class="line">TreeSet&lt;String&gt; result = stream.collect(Collectors.toCollection(TreeSet::new));</div><div class="line"></div><div class="line">//HashSet中</div><div class="line">HashSet&lt;String&gt; result= stream.collect(Collectors.toCollection(HashSet::new));</div><div class="line">//依次类推.</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//如果想将流中所有字符串链接起来</div><div class="line">String result = stream.collect(Collectors.joining());</div><div class="line">//通过分隔符链接起来</div><div class="line">String result = stream.collect(Collectors.joining(&quot;,&quot;));</div><div class="line">//如果将字符串链接前,流中包含其他对象,首先要将这些对象转换为字符串,如</div><div class="line">String result = stream.map(Object::toString).collect(Collectors.joining(&quot;,&quot;));</div><div class="line"></div><div class="line">//如果要通过一个对象来获取流的总和,平均值,最大值,最小值,那么</div><div class="line">    IntSummaryStatistics intSummaryStatistics = stream.collect(Collectors.summarizingInt(n-&gt;n));</div><div class="line">    System.out.println(intSummaryStatistics.getAverage()); //平均值</div><div class="line">    System.out.println(intSummaryStatistics.getCount());  //个数</div><div class="line">    System.out.println(intSummaryStatistics.getMax());  //最大值</div><div class="line">    System.out.println(intSummaryStatistics.getSum());  //总和</div></pre></td></tr></table></figure>
<p>前面说的<code>forEach</code>不仅仅可以用在集合上,也可用在Stream对象上,如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stream.forEach(System.out::println); //打印每个元素的值,但是在并发的时候可能会以任意顺序</div><div class="line">stream.forEachOrdered(System.out::println); //按照顺序打印</div></pre></td></tr></table></figure></p>
<p>注意,forEach,forEachOrdered都是终止操作,所以在调用它的时候,你不能在使用该流对象,如果想要打印某些东西,可以选择使用<code>peek</code>方法.</p>
<h2 id="将结果收集到Map中"><a href="#将结果收集到Map中" class="headerlink" title="将结果收集到Map中"></a>将结果收集到Map中</h2><p>既然可以将Stream收集到Set,List中,当然也可以收集到Map中,这样就方便进行通过key来查找,<code>Collectors.toMap()</code>有两个参数,分别用来生成键和值.如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Map&lt;Integer,String&gt; map = stream.collect(Collectors.toMap(Person::getId,Person::getName));</div><div class="line">//如果想要把值变为实际元素,可以换为 Function.identity()</div><div class="line">Map&lt;Integer,String&gt; map = stream.collect(Collectors.toMap(Person::getId,Function.identity()));</div></pre></td></tr></table></figure></p>
<p>如果多个元素具有相同的键,则会抛出IllegalStateException异常,不过可以通过指定第三个函数参数,来根据已有值和新值,决定该键最终应该使用哪个值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Map&lt;Integer,String&gt; map = stream.collect(Collectors.toMap(Person::getId,Function.identity(),(existValue,newValue)-&gt;existValue));</div><div class="line">//这样出现冲突键,值不会变,抛弃新值</div></pre></td></tr></table></figure></p>
<p>如果要转换成一个TreeMap对象,则需要在上述例子中加上第四个参数,构造函数参数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Map&lt;Integer,String&gt; map = stream.collect(Collectors.toMap(Person::getId,</div><div class="line">Function.identity(),</div><div class="line">(existValue,newValue)-&gt;existValue),</div><div class="line">TreeMap::new);</div></pre></td></tr></table></figure></p>
<h2 id="分组和分片"><a href="#分组和分片" class="headerlink" title="分组和分片"></a>分组和分片</h2><p>对某个流,使用流中的某一值进行分组,方法是groupingBy,类似数据库中的groupBy.<br>如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;Boolean,List&lt;Integer&gt;&gt; map = stream.collect(Collectors.groupingBy(i-&gt;i&gt;5));</div></pre></td></tr></table></figure></p>
<p>其中的键和groupingBy返回的键一一对应,这个操作最后将来stream分成两个部分,一个是大于5的,一个是小于5的.</p>
<p>但是如果要通过true,false进行分组,partitioningBy比groupingBY更有效率:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;Boolean,List&lt;Integer&gt;&gt; map = stream.collect(Collectors.partitioningBy(i-&gt;i&gt;5));</div></pre></td></tr></table></figure></p>
<p>但是partitioningBy返回的boolean类型,只能分组这种类型,而groupBy可以分组任何类型.</p>
<p>一般上述groupingBy默认返回的值是List类型的,如果想要对列表进行操作,比如将List转换为Set,则groupingBy中就需要传入第二个参数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;Boolean,Set&lt;Integer&gt;&gt; map = stream.collect(Collectors.groupingBy(i-&gt;i&gt;5),Collectors.toSet());</div></pre></td></tr></table></figure></p>
<p>其中groupingBy中第二个参数被称为收集器,Java8中提供了很多收集器如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//收集元素的总个数</div><div class="line">Map&lt;Boolean,Long&gt; map = stream.collect(Collectors.groupingBy(i-&gt;i&gt;5,Collectors.counting() ));</div><div class="line">//对每个元素进行求和</div><div class="line">Map&lt;Boolean,Integer&gt; map = stream.collect(Collectors.groupingBy(i-&gt;i&gt;5,Collectors.summingInt(i-&gt;i)));</div><div class="line">//生成每个组中的最大值或最小值,maxBy,minBy要传入一个比较器</div><div class="line">Map&lt;Boolean,Set&lt;Integer&gt;&gt; map = stream.collect(Collectors.groupingBy(i-&gt;i&gt;5),Collectors.maxBy(...));</div></pre></td></tr></table></figure></p>
<p>还有其他一些收集器,不常用,所以不列举.<br>一定要注意,不传收集器的时候,默认返回的值是List类型的,如果传入收集器,会返回收集器对应的类型.</p>
<h2 id="原始类型流"><a href="#原始类型流" class="headerlink" title="原始类型流"></a>原始类型流</h2><p>Stream因为使用泛型,所以如果要传入int类型,只能传入包装的Integer,这样会使得效率降低,所以Java8提供了原始类型流,如<code>IntStream</code>,<code>LongStream</code>,<code>DoubleStream</code>等,如果要存储short,char,int,boolean等数据,要使用<code>IntStream</code>,如果要存储float,double要使用<code>DoubleStream</code>.</p>
<p>IntStream和LongStream还拥有静态方法<code>range</code>和<code>rangeClosed</code><br>如:<code>IntStream stream = IntStream.range(0,100)</code>产生0~99,而<code>IntStream stream = IntStream.rangeClosed(0,100)</code>产生0~100.</p>
<p>当你拥有一个对象流的时候,可以通过mapToInt(),mapToLong(),mapToDouble()方法,将它抓换为一个原始类型流.如:<br>将来一个字符串流,转换为字符串长度的原始类型流:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">IntStream lengths = words.mapToInt(String::length);</div></pre></td></tr></table></figure></p>
<p>而如果要将一个原始类型流封装为对象流,则:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream&lt;Integer&gt; stream = IntStream.range(0,100).boxed();</div></pre></td></tr></table></figure></p>
<p>原始类型流和对象流的区别:</p>
<ul>
<li>toArray()方法返回原始类型数组</li>
<li>产生的Optional结果为OptoinalInt,OptionalLong或OptionalDouble等</li>
<li>方法sum,averange,max,min,而在对象流中没有这些方法</li>
<li>summaryStatistics产生XxxSummaryStatistics等</li>
</ul>
<h2 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h2><p>流操作会创建一个串行流,而parallel可以将任意串行流转换为并行流.<br>如:<code>Stream.of(someArr).parallel()</code>在终止方法执行前,流处于并行模式,那么所有延迟执行的流操作都会被并行执行.<br>你需要确保传递给并行流操作的函数都是线程安全的.比如AtomicInteger的对象,可以用来做计数器.<br>可以放弃有序来加快limit()的方法速度</p>
<h1 id="新的日期和事件函数"><a href="#新的日期和事件函数" class="headerlink" title="新的日期和事件函数"></a>新的日期和事件函数</h1><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><p>使用<code>Instant.now()</code>获取当前的瞬时时间点,可以使用<code>equals</code>和<code>compareTo</code>方法来比较两个瞬时点.可以通过Duration.between()来计算两个瞬时点的距离.比如计算某个代码的执行时间:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Instant start = Instant.now();</div><div class="line">//some code</div><div class="line">Duration timeDuration = Duration.between(start,Instant.now());</div><div class="line">System.out.println(timeDuration.toMillis());</div></pre></td></tr></table></figure></p>
<p>一个<code>Duration</code>对象表示两个瞬时之间的时间量,你可以通过调用toNanos,toMilis,toSeconds,…等方法得到各种事件单位来表示的Duration对象.</p>
<p>Duration和Instant对象中有很多方法,比如加一段时间,成倍增长一段时间等等.<br>比如检查某个算法是否比另一个算法至少快10倍:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Duration time = Duration.between(start2,end2);</div><div class="line">boolean overTenTimeFaster = time.multipliedBy(10).minus(time2).isNegative();</div></pre></td></tr></table></figure></p>
<h2 id="本地日期"><a href="#本地日期" class="headerlink" title="本地日期"></a>本地日期</h2><p>LocalDate是一个带有年份,月份,当月天数的日期,创建一个LocalDate可以使用静态方法now或of:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalDate now = LocalDate.now(); //今天的日期</div><div class="line">LocalDate now = LocalDate.of(1994,11,13);//特定的时期</div></pre></td></tr></table></figure></p>
<p>该对象和java.util.Date中不按常理的做法(月份从0开始,年份从1990开始)不同,你可以使用与正常生活中一样的数字来表示月份.</p>
<p>下表展示LocalDate常用的方法:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>now,of</td>
<td>静态方法,用于创建</td>
</tr>
<tr>
<td>plusDays,plusWeeks,plusMonths,plusYears</td>
<td>向当前LocalDate对象添加天数,周数,月年等.</td>
</tr>
<tr>
<td>minusDays,minusWeeks…</td>
<td>减去</td>
</tr>
<tr>
<td>plus,minus</td>
<td>添加或减少一个Duration或Period</td>
</tr>
<tr>
<td>withDayOfMonth,withDayOfYear,withMonth,withYear</td>
<td>将月份天数,年份天数,月份,年份修改为指定值,并返回一个新的LocalDate对象</td>
</tr>
<tr>
<td>getDayOfMonth</td>
<td>获取月份天数</td>
</tr>
<tr>
<td>getDayOfYear</td>
<td>获取年份天数</td>
</tr>
<tr>
<td>getDayOfWeek</td>
<td>获取星期几(返回DayOfWeek的枚举值)</td>
</tr>
<tr>
<td>getMonth,getMonthValue</td>
<td>获取月份,或者Month枚举值</td>
</tr>
<tr>
<td>getYear</td>
<td>获得年份</td>
</tr>
<tr>
<td>Until</td>
<td>获得两个日期之间的Period对象,或者指定ChronoUnits的数字</td>
</tr>
<tr>
<td>isBefore,isAfter</td>
<td>比较两个LocalDate</td>
</tr>
<tr>
<td>isLeapYear</td>
<td>如果当年为闰年,则返回true</td>
</tr>
</tbody>
</table>
<p>除了LocalDate,Java8中还提供了MonthDay,YearMonth和Year来描述部分日期,如MonthDay可以表示12.25,不用指定年份.<br>通过以上方法,可以轻松获取日期对象,比如计算程序员日,程序员是每年的256日,那么通过下列代码轻松获取:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LocalDate programmerDay = LocalDate.of(2014.1.1).plusDays(255);</div></pre></td></tr></table></figure></p>
<h2 id="日期校正器"><a href="#日期校正器" class="headerlink" title="日期校正器"></a>日期校正器</h2><p>对于一些需要安排调度的应用程序来说,通常要计算例如”每月的第一个周二”这样的日期TemporalAdjusters类提供很多静态方法来进行常用的校正.:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalDate firstTuesday = LocalDate.of(2017,4,1).with(TemporalAdjusters.nextOrSame(DayOfWeek.TUESDAY));</div><div class="line">System.out.println(firstTuesday);</div></pre></td></tr></table></figure></p>
<p>这段代码打印2017.4.1的下一个周二,也就是4月的第一个周二.</p>
<h2 id="本地时间"><a href="#本地时间" class="headerlink" title="本地时间"></a>本地时间</h2><p>LocalTime表示一天中的某个时间,如15:30:00,可以使用now或of创建实例.</p>
<h2 id="格式化和解析"><a href="#格式化和解析" class="headerlink" title="格式化和解析"></a>格式化和解析</h2><p>DateTimeFormatter来格式化,自定义方式是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;).format(..);</div></pre></td></tr></table></figure></p>
<p>其中ofPattern返回一个DateTimeFormatter对象,通过对象的format方法,可以对LocalDateTime,LocalDate,LocalTime等进行格式化.</p>
<h2 id="遗留代码相互操作"><a href="#遗留代码相互操作" class="headerlink" title="遗留代码相互操作"></a>遗留代码相互操作</h2><p>Instant类相当于java.util.Date类,java8中Date对象可以通过toInstant方法进行转换,而from正好相反.<br>ZonedDateTime类似于java.util.GregorianCalendar类,后者也增加了转换方法toZonedDateTime</p>
<h1 id="并发增强"><a href="#并发增强" class="headerlink" title="并发增强"></a>并发增强</h1><h2 id="原子值"><a href="#原子值" class="headerlink" title="原子值"></a>原子值</h2><p>在java.util.concurrent.atomic包中提供了用于支持无锁可变变量的类,如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static AtomicLong nextNumber = new AtomicLong();</div><div class="line"></div><div class="line">//在某些线程中</div><div class="line">long id = nextNumber.incrementAndGet();</div></pre></td></tr></table></figure></p>
<p>通过这种原子类增加并赋值的操作,不会被打断,不论多少线程访问,都能返回正确的结果.<br>java 5中提供了很多设置,增加,减少值的原子操作,但是如果要进行更复杂的操作,就必须使用commpareAndSet方法,比如下列方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static AtomicLong largest = new AtomicLong();</div><div class="line">//在某些线程中</div><div class="line">largest.set(Math.max(largest.get(),anotherValue));</div></pre></td></tr></table></figure></p>
<p>如上所述的更新并不是原子操作,如果要更新该值,应该使用下列方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">do&#123;</div><div class="line">	oldValue = larget.get();</div><div class="line">	newValue = Math.max(oldValue,anotherValue);</div><div class="line">&#125;while(!largest.compareAndSet(oldValue,newValue));</div></pre></td></tr></table></figure></p>
<p>如果另一个线程也在更新largest,很可能已经更新成功了,那么随后的compareAndSet会返回false,并不会设置新值.这样程序就重新循环设置新值.虽然听上去效率不高,但实际上该方法映射为底层的一个处理方法,比一个锁要快很多.</p>
<p>但是在lambda中,不需要在书写循环来更新某个原子值,只需要提供一个lambda表达式,更新操作就会自动完成:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">largetst.updateAndGet(x-&gt;Math.max(x,anotherValue));</div><div class="line">//or</div><div class="line">largest.accumulateAndGet(anotherValue,Math::max);</div></pre></td></tr></table></figure></p>
<h1 id="杂项改进"><a href="#杂项改进" class="headerlink" title="杂项改进"></a>杂项改进</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>通过<code>String.join()</code>方法来将某个数组或者<code>Iterable</code>对象,通过某个分隔符链接起来.如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String arr[] = &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;;</div><div class="line">String result = String.join(&quot;,&quot;,arr);</div></pre></td></tr></table></figure></p>
<p>可以把<code>join</code>方法想象为和<code>split</code>相反的方法.</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java8/" rel="tag"># java8</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/13/头条面试/" rel="next" title="头条面试">
                <i class="fa fa-chevron-left"></i> 头条面试
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/19/LinkedList实现栈或队列/" rel="prev" title="LinkedList实现栈或队列">
                LinkedList实现栈或队列 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/04/16/Java8-特性学习/"
           data-title="Java8 特性学习" data-url="http://yoursite.com/2017/04/16/Java8-特性学习/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="QxG" />
          <p class="site-author-name" itemprop="name">QxG</p>
           
              <p class="site-description motion-element" itemprop="description">努力才会有机遇</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">65</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#lambda表达式"><span class="nav-number">1.</span> <span class="nav-text">lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#语法"><span class="nav-number">1.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数式接口"><span class="nav-number">1.2.</span> <span class="nav-text">函数式接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法引用"><span class="nav-number">1.3.</span> <span class="nav-text">方法引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造器引用"><span class="nav-number">1.4.</span> <span class="nav-text">构造器引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量作用域"><span class="nav-number">1.5.</span> <span class="nav-text">变量作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#默认方法"><span class="nav-number">1.6.</span> <span class="nav-text">默认方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口中的静态方法"><span class="nav-number">1.7.</span> <span class="nav-text">接口中的静态方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Stream"><span class="nav-number">2.</span> <span class="nav-text">Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建Stream"><span class="nav-number">2.1.</span> <span class="nav-text">创建Stream</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#filter-map和flatMap"><span class="nav-number">2.2.</span> <span class="nav-text">filter,map和flatMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#提取子流和组合流"><span class="nav-number">2.3.</span> <span class="nav-text">提取子流和组合流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有状态的转换"><span class="nav-number">2.4.</span> <span class="nav-text">有状态的转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单的聚合方法"><span class="nav-number">2.5.</span> <span class="nav-text">简单的聚合方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Optional类型"><span class="nav-number">2.6.</span> <span class="nav-text">Optional类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建可选值"><span class="nav-number">2.6.1.</span> <span class="nav-text">创建可选值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用flatMap来组合可选函数"><span class="nav-number">2.6.2.</span> <span class="nav-text">使用flatMap来组合可选函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#聚合操作"><span class="nav-number">2.7.</span> <span class="nav-text">聚合操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#收集结果"><span class="nav-number">2.8.</span> <span class="nav-text">收集结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将结果收集到Map中"><span class="nav-number">2.9.</span> <span class="nav-text">将结果收集到Map中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分组和分片"><span class="nav-number">2.10.</span> <span class="nav-text">分组和分片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原始类型流"><span class="nav-number">2.11.</span> <span class="nav-text">原始类型流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并行流"><span class="nav-number">2.12.</span> <span class="nav-text">并行流</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#新的日期和事件函数"><span class="nav-number">3.</span> <span class="nav-text">新的日期和事件函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#时间线"><span class="nav-number">3.1.</span> <span class="nav-text">时间线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本地日期"><span class="nav-number">3.2.</span> <span class="nav-text">本地日期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#日期校正器"><span class="nav-number">3.3.</span> <span class="nav-text">日期校正器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本地时间"><span class="nav-number">3.4.</span> <span class="nav-text">本地时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#格式化和解析"><span class="nav-number">3.5.</span> <span class="nav-text">格式化和解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#遗留代码相互操作"><span class="nav-number">3.6.</span> <span class="nav-text">遗留代码相互操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#并发增强"><span class="nav-number">4.</span> <span class="nav-text">并发增强</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原子值"><span class="nav-number">4.1.</span> <span class="nav-text">原子值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#杂项改进"><span class="nav-number">5.</span> <span class="nav-text">杂项改进</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串"><span class="nav-number">5.1.</span> <span class="nav-text">字符串</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QxG</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"qxgzone"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  





  

  

  

  

  

  

</body>
</html>
