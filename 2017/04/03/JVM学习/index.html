<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="内存java运行时数据区：">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM学习">
<meta property="og:url" content="http://yoursite.com/2017/04/03/JVM学习/index.html">
<meta property="og:site_name" content="Everything Changes">
<meta property="og:description" content="内存java运行时数据区：">
<meta property="og:image" content="http://yoursite.com/images/java运行时数据区.png">
<meta property="og:image" content="http://yoursite.com/images/Java句柄.png">
<meta property="og:image" content="http://yoursite.com/images/直接指针.png">
<meta property="og:image" content="http://yoursite.com/images/可达性分析.png">
<meta property="og:image" content="http://yoursite.com/images/标记清除算法.png">
<meta property="og:image" content="http://yoursite.com/images/复制算法.png">
<meta property="og:image" content="http://yoursite.com/images/标记-整理.png">
<meta property="og:image" content="http://yoursite.com/images/收集器.png">
<meta property="og:image" content="http://yoursite.com/images/收集器关系.png">
<meta property="og:image" content="http://yoursite.com/images/jstat">
<meta property="og:image" content="http://yoursite.com/images/jconsole.png">
<meta property="og:image" content="http://yoursite.com/images/class文件格式.png">
<meta property="og:image" content="http://yoursite.com/images/常量池的项目类型.png">
<meta property="og:image" content="http://yoursite.com/images/常量结构.png">
<meta property="og:image" content="http://yoursite.com/images/14种常量项结构总表.png">
<meta property="og:image" content="http://yoursite.com/images/14种常量项结构总表2.png">
<meta property="og:image" content="http://yoursite.com/images/类的生命周期.png">
<meta property="og:image" content="http://yoursite.com/images/类加载器.png">
<meta property="og:image" content="http://yoursite.com/images/栈帧的概念结构.png">
<meta property="og:image" content="http://yoursite.com/images/方法表结构.png">
<meta property="og:updated_time" content="2017-04-09T16:26:31.394Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JVM学习">
<meta name="twitter:description" content="内存java运行时数据区：">
<meta name="twitter:image" content="http://yoursite.com/images/java运行时数据区.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/04/03/JVM学习/"/>





  <title> JVM学习 | Everything Changes </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Everything Changes</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/03/JVM学习/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="QxG">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Everything Changes">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Everything Changes" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                JVM学习
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-03T21:25:29+08:00">
                2017-04-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/03/JVM学习/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/03/JVM学习/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>java运行时数据区：<br><img src="/images/java运行时数据区.png" alt=""></p>
<a id="more"></a>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>线程私有<br>当前所执行字节码的行号指示器。<br>唯一一个在JAVA虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>线程私有<br>每个方法在执行的同事都会创建一个栈帧(Stack Frame)存储局部变量表，操作数栈，动态链接，方法入口等信息。<br>局部变量表存放编译期可知的基本数据类型，对象引用。<br>该区域会抛出StackOverflowError异常。如果无法申请到足够的内存抛OutOfMemoryError.</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>线程私有<br>为虚拟机使用到的native方法服务.<br>有的虚拟机(如 Sun HotSpot)直接把本地方法栈和虚拟机栈合二为一.</p>
<h2 id="JAVA堆"><a href="#JAVA堆" class="headerlink" title="JAVA堆"></a>JAVA堆</h2><p>所有线程共享.<br>虚拟机启动时创建.<br>用于存放对象实例.<br>是垃圾收集器管理的主要区域,所以也称为GC堆.<br>分为新生代和老年代,再细致一点则分为Eden(伊甸园),From Survivor,To Survivor,老年代等.<br>Java堆可以处于物理上不连续的内存空间中,只要逻辑上是连续的即可.</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>所有线程共享.<br>存储虚拟机加载的类信息(如类名,访问修饰符,常量池,字段描述),常量,静态变量,即时编译器(JIT)编译后的代码等数据.<br>别名:non-heap,永久代<br>垃圾收集行为在这个区域比较少出现,该区域内存回收目标主要针对常量池的回收和对类型的加载.</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>是方法区的一部分.<br>Class文件中还有一项信息是常量池,用于存放编译器生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放.<br>String.intern():如果字符串常量池中已经包含一个等于此String对象的字符串,则返回代表池中这个字符串的String对象;否则,将此String对象包含的字符串添加到常量池中,并且返回此String对象的引用,在测试运行时常量池内存溢出的时候,就可以使用该方法.</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>遇到new指令时首先检查这个指令的参数能否在常量池中定位到一个类的符号引用,并且检查该符号代表的类是否已经被加载,解析和初始化,若没有则加载.</p>
<p>类加载检查通过后,为对象分配内存,对象所需内存大小在类加载完成后可完全确定.<br>Java堆规整时,采用指针碰撞分配内存,否则采用空闲列表.<br>虚拟机还要对对象进行必要的设置,在对象头(Object header)中设置对象哈希码,gc分代等等</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>HotSpot中,对象在内存中存储布局分为3块:对象头,实例数据和对齐填充.<br>对象头包含两部分,第一个部分存储的是对象自身运行时数据,如hashCode,GC分代,锁等.第二部分是类型指针,通过该指针确定这个对象是哪个类的实例.<br>如果对象是一个Java数组,在对象头必须有一块用于记录数组长度的数据</p>
<p>实例数据就是保存各种类型的字段内容,无论是父类继下来的还是子类定义的,都需要记录下来.</p>
<p>对齐填充不是必然存在的,仅仅起填充作用,因HotSpot自动内存管理系统要求对象起始地址必须是8字节的整数.如果数据没有对齐,那么就通过对齐填充来将对象数据对齐.</p>
<h2 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h2><p>通过栈中的引用来操作堆上的具体对象,但是Java虚拟机规范中没有定义这个引用应该如何定位,所以对不同虚拟机而言,定位方式也不同.主流的定位方式有句柄和直接指针两种.</p>
<p>句柄:Java堆中4划分出一块内存作为句柄池来存储句柄,栈中的对象引用就是存储的句柄地址,句柄包含对象实例数据和类型数据的地址.如:<br><img src="/images/Java句柄.png" alt=""></p>
<p>直接指针:栈中引用存储的就是对象的地址,如:<br><img src="/images/直接指针.png" alt=""></p>
<p>使用句柄的好处是存储稳定的句柄,对象被移动,只改变句柄的实例数据指针,引用本身不需要更改,直接指针的好处是速度更快.HotSpot使用的就是直接指针.</p>
<h1 id="垃圾收集器和内存分配策略"><a href="#垃圾收集器和内存分配策略" class="headerlink" title="垃圾收集器和内存分配策略"></a>垃圾收集器和内存分配策略</h1><h2 id="对象是否存活"><a href="#对象是否存活" class="headerlink" title="对象是否存活"></a>对象是否存活</h2><p>确定哪些对象还活着,使用的算法有引用计数法和可达性分析法,注意这两个方法不是垃圾收集算法,只是判断对象是否存活的方法.</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象添加一个引用计数器,每当有一个地方引用它时,计数器加1,引用失效时,计数器减1.任何时刻计数器为0的对象就不可能再被使用.<br>主流的Java虚拟机里面没有使用该算法,原因在于它很难解决对象之间相互循环引用的问题.</p>
<h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p>基本思想就是通过一系列的称为”GC Roots”的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链,当一个对象到GC Roots没有任何引用链相连,即该对象从GC Roots不可达,证明此对象是不可用的.如图,Object5,6,7虽然互相关联,但是从GC Roots是不可达的,所以它们将被判定为是可回收对象.<br><img src="/images/可达性分析.png" alt=""></p>
<p>Java中可以作为GC Roots的对象包括下面几种:</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>JDK1.2后Java对引用的概念进行了扩充,将引用分为强引用(StrongReference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)4种,这4种引用强度依次逐渐减弱。</p>
<p>强引用就是指在程序代码之中普遍存在的,类似“Object obj=new Object()”这类的引用,只要强引用还存在,垃圾收集器永远不会回收掉被引用的对象。</p>
<p>软引用是内存不足的时候才会进行回收.</p>
<p>弱引用无论当前内存是否足够,都会回收掉只被弱引用关联的对象。</p>
<p>虚引用也称为幽灵引用或者幻影引用,它是最弱的一种引用关系。一个对象是否有虚引用的存在,完全不会对其生存时间构成影响,也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p>
<h2 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h2><p>对于一个对象,如果可达性分析后发现不可达后,并非是非死不可的,这个时候它们只是处于缓刑阶段.</p>
<p>真正宣告一个对象死亡,至少经历两次标记过程:可达性分析后发现不可达的对象,将被第一次标记并进行筛选,筛选的条件是该对象是否有finalize()方法,如果没有覆盖或已覆盖但已执行过一次,则这些对象不会去执行finalize()方法.<br>如果对象有finalize()方法且从未被执行过,那么就会将该对象放在F-Queue队列中,并由虚拟机创建的低优先级的Finalizer线程去执行它.但不会等待该方法执行结束,原因在于怕导致阻塞现象.</p>
<p>fianlize()方法是对象自救的最后一次机会,如果自救成功,则finalize()方法就失效了,因为该方法只能被调用一次.一般不建议使用该方法,完全可以将之遗忘.</p>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>方法区的内存也是需要回收的.<br>永久代垃圾收集主要回收两部分内容:废弃常量和无用的类.<br>废弃常量举例来说,”abc”常量如果在程序中没有任何一个String的引用来指向它,如果有必要的话,”abc”就会被清理出常量池.</p>
<p>判断一个常量是否是废弃常量比较简单,但是判断是否是无用类比较苛刻:</p>
<ul>
<li>该类的所有实例都已经被回收</li>
<li>加载该类的ClassLoader已被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用,无法通过反射访问该类的方法.</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>最基础的算法<br>分两个阶段:标记和清除,首先标记所有需要回收的对象,标记完成后进行清除工作.</p>
<p>缺点:效率不高;清除后产生空间碎片.<br><img src="/images/标记清除算法.png" alt=""></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将内存分为大小相等的两块,每次只能使用一块,当一块内存用完时,将存活的对象复制到另一块上,并将之前的内存块清除.</p>
<p>缺点:浪费过多的资源,代价太高<br><img src="/images/复制算法.png" alt=""></p>
<p>不过现在的商业虚拟机都采用这种算法来回收新生代,将内存分为较大的Eden空间和两块较小的Survivor空间,每次使用Eden和其中一块Survivor,当回收时,将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上,最<br>后清理掉Eden和刚才用过的Survivor空间.</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记过程仍然与“标记-清除”算法一样,但后续步骤不是直接对可回收对象进行清理,而是让所有存活的对象都向一端移动,然后直接清理掉端边界以外的内存.如图:</p>
<p><img src="/images/标记-整理.png" alt=""></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用该算法,将Java堆内存分为几块,一般分为老年代和新生代,新生代中采用复制算法,老年代中采用标记-整理或标记清除算法.</p>
<h3 id="HotSpot采用的算法"><a href="#HotSpot采用的算法" class="headerlink" title="HotSpot采用的算法"></a>HotSpot采用的算法</h3><p>首先要<strong>枚举根节点</strong>,即GC roots,但是一般根节点有数百兆,这样会消耗更多内存.<br>进行GC的时候,不能出现分析过程中对象的引用关系还在不断变化的情况,所以在GC进行时必须停顿所有的Java线程.<br>准确式内存管理即虚拟机可以知道内存中某个位置的数据具体是什么类型.<br>目前主流的Java虚拟机使用的都是准确是GC,所以当执行系统停顿下来后,并不需要一个不漏地检查完所有执行上下文和全局的引用位置,虚拟机应当是有办法直接得知哪些地方存放着对象引用.HotSpot的实现中,使用OopMap数据结构来达到这个目的.类加载完成的时候,HotSpot会把对象内偏移量上是什么数据类型计算出来,在JIT编译过程中,也会在特定位置记录栈和寄存器中哪些位置是引用.这样GC扫描的时候就可以直接得知这些信息了.</p>
<p><strong>安全点</strong>:如果为每一条指令都分配OopMap,将会需要大量额外空间.而HotSpot也不是为每条指令生成OopMap,只是在特定位置记录这些信息,将这些位置称为安全点,即程序执行时并非在所有地方都能停顿下来开始GC,只有在到达安全点时才能暂停.<br>GC发生时要让所有线程跑到安全点再停顿下来,采用的方式有两种:抢先式中断和主动式中断,其中抢先式中断不需<br>要线程的执行代码主动去配合,在GC发生时,首先把所有线程全部中断,如果发现有线程中断的地方不在安全点上,就恢复线程,让它“跑”到安全点上.    现在几乎没有虚拟机采用这种方式.而主动式中断的思想是当GC需要中断线程的时候,不直接对线程操作,仅仅简单地设置一个标志,各个线程执行时主动去轮询这个标志,发现中断标志为真时就自己中断挂起。</p>
<p><strong>安全区域</strong>:如果遇到线程sleep而长时间无法到达安全点,JVM显然不可能等到线程sleep结束才去中断其运行,这个时候就需要安全区域.安全区域是指:在一段代码片段之中,引用关系不会发生变化.所以安全区域中任意地方开始GC都是安全的.</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>Serial收集器:单线程收集器,新生代<br>ParNew收集器:Serial收集器的多线程版本<br>Parallel Scavenge:新生代收集器,使用复制算法,又是并行的多线程收集器<br>Serial Old:Serial的老年代版本,标记-整理算法<br>Parallel Old:老年代版本,使用多线程和标记-整理算法</p>
<p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上,这类应用尤其重视服务的响应速度,希望系统停顿时间最短,以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。<br>使用标记清除算法实现,整个步骤分为4步:</p>
<ol>
<li>初始标记(CMS initial mark)</li>
<li>并发标记(CMS concurrent mark)</li>
<li>重新标记(CMS remark)</li>
<li>并发清除(CMS concurrent sweep)<br>初始标记和重新标记需要暂停其他所有线程(Stop The World),初始标记仅仅只是标记一下GC Roots能直接关联到的对象,速度很快,并发标记阶段就是进行GC RootsTracing的过程,而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录,这个阶段的停顿时间一般会比初始标记阶段稍长一些,但远比并发标记的时间短。由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起<br>工作,所以,从总体上来说,CMS收集器的内存回收过程是与用户线程一起并发执行的。</li>
</ol>
<p>G1收集器:反正就是一个很吊的收集器…</p>
<p>上网搜刮的两张图片:<br><img src="/images/收集器.png" alt=""></p>
<p><img src="/images/收集器关系.png" alt=""></p>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>大多数情况下,对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时,虚拟机将发起一次Minor GC。</p>
<p>Minor GC:指发生在新生代的垃圾收集动作,因为Java对象大多都具备朝生夕灭的特性,所以Minor GC非常频繁,一般回收速度也比较快。<br>Major GC/Full GC:指发生在老年代的GC,出现了Major GC,经常会伴随至少一次的Minor GC(但非绝对的,在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。</p>
<p><strong>大对象直接进入老年代</strong><br>所谓的大对象是指,需要大量连续内存空间的Java对象,最典型的大对象就是那种很长的字符串以及数组(笔者列出的例子中的byte[]数组就是典型的大对象)。大对象对虚拟机的内存分配来说就是一个坏消息(替Java虚拟机抱怨一句,比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”,写程序的时候应当避免),经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p>
<p><strong>长期存活的对象将进入老年代</strong><br>虚拟机给每个对象定义了一个对象年龄(Age)计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活,并且能被<br>Survivor容纳的话,将被移动到Survivor空间中,并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC,年龄就增加1岁,当它的年龄增加到一定程度(默认为15岁),就将会被晋升到老年代中。</p>
<p><strong>动态对象年龄判定</strong><br>为了能更好地适应不同程序的内存状况,虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代,如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半,年龄大于或等于该年龄的对象就可以直接进入老年代,无须等到MaxTenuringThreshold中要求的年龄。</p>
<p><strong>空间分配担保</strong><br>在发生Minor GC之前,虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间,如果这个条件成立,那么Minor GC可以确保是安全的。如果不成立,则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许,那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小,如果大于,将尝试着进行<br>一次Minor GC,尽管这次Minor GC是有风险的;如果小于,或者HandlePromotionFailure设置不允许冒险,那这时也要改为进行一次Full GC。</p>
<p>解释一下“冒险”是冒了什么风险,前面提到过,新生代使用复制收集算法,但为了内存利用率,只使用其中一个Survivor空间来作为轮换备份,因此当出现大量对象在MinorGC后仍然存活的情况(最极端的情况就是内存回收后新生代中所有对象都存活),就需要老年代进行分配担保,把Survivor无法容纳的对象直接进入老年代。与生活中的贷款担保类似,老年代要进行这样的担保,前提是老年代本身还有容纳这些对象的剩余空间,一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的,所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值,与老年代的剩余空间进行比较,决定是否进行Full GC来让老年代腾出更多空间。</p>
<p>取平均值进行比较其实仍然是一种动态概率的手段,也就是说,如果某次Minor GC存活后的对象突增,远远高于平均值的话,依然会导致担保失败(Handle Promotion Failure)。如果出现了HandlePromotionFailure失败,那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的,但大部分情况下都还是会将HandlePromotionFailure开关打开,避免Full GC过于频繁.</p>
<h1 id="虚拟机性能监控及故障处理"><a href="#虚拟机性能监控及故障处理" class="headerlink" title="虚拟机性能监控及故障处理"></a>虚拟机性能监控及故障处理</h1><p><strong>jps</strong>:列出正在运行的虚拟机进程,显示虚拟机执行的主类.<br><code>jps [options] [hostid]</code>,hostid为RMI注册表中注册的主机名.<br>|参数名|作用|<br>|——|—|<br>|-q|只输出LVMID,省略主类的名称|<br>|-m|输出虚拟机进程启动时传递给主类main()的参数|<br>|-l|输出主类的全名,如果进程执行的是jar包,输出jar包路径|<br>|-v|输出虚拟机进程启动时JVM参数|</p>
<p>说到参数这里说明一下 -Xms是指定堆的最小指,-Xmx是指定堆的最大值</p>
<p><strong>jstat</strong>:虚拟机统计信息监控工具,注意是监控工具.<br><code>jstat [option] [vmid] [interval] [count]</code><br>本地虚拟机中VMID和LVMID是一致的,远程时:<code>protocol://vmid@hostname:port/servername</code><br>interval是间隔时间,后面可以加上[s|ms]表示时间单位<br>count表示查询次数.</p>
<p>如<code>jstat -gc 2764 250 20</code>表示每250ms查询一次进程2764垃圾收集状况,一共查询20次.<br>参数为下表:<br><img src="/images/jstat" alt=""></p>
<p>摘抄书中样例:<br><code>jstat -gcutil 2764</code><br>结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">S0 S1 E O P YGC YGCT FGC FGCT GCT</div><div class="line">0.00 0.00 6.20 41.42 47.20 16 0.105 3 0.472 0.577</div></pre></td></tr></table></figure></p>
<p>这台服务器的新生代Eden区(E,表示Eden)使用了6.2%的空间,两个Survivor区(S0、S1,表示Survivor0、Survivor1)里面都是空的,老年代(O,表示Old)和永久代(P,表示Permanent)则分别使用了41.42%和47.20%的空间。程序运行以来共发生Minor GC(YGC,表示Young GC)16次,总耗时0.105秒,发生Full GC(FGC,表示FullGC)3次,Full GC总耗时(FGCT,表示Full GC Time)为0.472秒,所有GC总耗时(GCT,表示GC Time)为0.577秒。</p>
<p><strong>jmap</strong>:Java内存映像工具<br>用于生成堆转储快照,还可查询finalize执行队列,Java堆和永久代的详细信息.<code>jmap [option] pid</code></p>
<p><strong>jhat</strong>:虚拟机堆转储快照分析工具<br>jhat 内置了一个微型的HTTP/HTML服务器,生成dump文件的分析结果后,可以在浏览器中查看.</p>
<p><strong>jstack</strong>:Java堆栈跟踪工具</p>
<h2 id="JDK可视化工具"><a href="#JDK可视化工具" class="headerlink" title="JDK可视化工具"></a>JDK可视化工具</h2><p><strong>JConsole</strong>:Ubuntu环境下直接通过终端键入 <code>jconsole</code>即可进入图形化界面.开启后会自动搜索出本地运行的所有虚拟机进程,不需要用户自己使用jps来查询.</p>
<p>测试的时候,发现idea有一个Main()进程在运行,突然就明白了,原来idea是用Java进行开发的.= =</p>
<p>这个图形界面包含的东西还很多,截个图观赏下.所以如果想要分析内存泄露,用这个也是可行的.<br><img src="/images/jconsole.png" alt=""></p>
<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p>Class文件是一组以8字节为基础单位的二进制流.</p>
<p>无符号数属于基本的数据类型,以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数,无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</p>
<p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型,所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据,整个Class文件本质上就是一张表,它由下表所示的数据项构成。<br><img src="/images/class文件格式.png" alt=""></p>
<p>Class文件比较严格,没有分隔符,哪个字节代表什么含义,长度是多少,先后顺序如何都不允许改变.</p>
<h2 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h2><p>每个Class文件的头4个字节被称为<strong>魔数</strong>(Magic Number),它的<strong>唯一</strong>作用是确定这个文件是否为一个能被虚拟机接受的Class文件。<br>很多文件存储标准中都使用魔数来进行身份识别,譬如图片格式,如gif或者jpeg等在文件头中都存有魔数.<br>魔数是固定值,用来表明这个文件是Class文件,Class文件的魔数是<code>0xCAFEBABE</code>.</p>
<p>紧接着魔数的4个字节存储的是Class文件的版本号:第5个和第6个字节是此版本号,第7,8个字节是主版本号.ava的版本号是从45开始的,JDK 1.1之后的每个JDK大版本发布主版本号向上加1(JDK 1.0~1.1使用了45.0~45.3的版本号),高版本的JDK能向下兼容以前版本的Class文件,但不能运行以后版本的Class文件,即使文件格式并未发生任何变化,虚拟机也必须拒绝执行超过其版本号的Class文件。</p>
<p>紧接着主次版本号之后的是常量池入口,常量池可以理解为Class文件中的资源仓库,它是Class文件结构中与其他项目关联最多的数据类型,也是占用Class文件空间最大的数据项目之一,同时它还是在Class文件中第一个出现的表类型数据项目。</p>
<p>由于常量池中常量的数量是不固定的,所以在常量池的入口需要放置一项u2类型的数据,及后的8,9字节来表示.代表常量池容量计数值,不过其计数从1开始,1表示容量为0. 为什么从1开始是有原因的,0表示其他特殊的含义.<br>常量池中主要存放两大类常量:字面量和符号引用.字面量比较接近Java语言层面的常量概念,如文本字符串,声明为final的常量值等.而符号引用属于编译原理方面的概念,包括:类和接口的全限定名,字段的名称和描述符,方法的名称和描述符.<br>常量池中每一项常量都是一个表,jdk1.7后,表结构共有14个:<br><img src="/images/常量池的项目类型.png" alt=""></p>
<p>这14个表都有一个共同的特点,就是表开始的第一位是一个u1类型的标志位,代表当前这个常量属于哪种常量类型.<br>比如:<br><img src="/images/常量结构.png" alt=""></p>
<p>tag是标志位,上面已经讲过了,它用于区分常量类型;name_index是一个索引值,它指向常量池中一个CONSTANT_Utf8_info类型常量,此常量代表了这个类(或者接口)的全限定名.</p>
<p>以下是总表:<br><img src="/images/14种常量项结构总表.png" alt=""><br><img src="/images/14种常量项结构总表2.png" alt=""></p>
<p>其他表集合就不一一给列举了.</p>
<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><p>虚拟机把描述类的数据从Class文件加载到内存,并对数据进行校验,转换解析和初始化,最终形成可以被虚拟机直接使用的Java类型,这就是虚拟机的类加载机制.</p>
<p>与那些在编译时需要进行连接工作的语言不同,在Java语言里面,类型的加载、连接和初始化过程都是在程序运行期间完成的.</p>
<p>类从被加载到虚拟机内存中开始,到卸载出内存为止,它的整个生命周期包括:加载,验证,准备,解析,初始化,使用,和卸载等7个阶段.其中验证准备解析3个阶段统称为连接,如图:<br><img src="/images/类的生命周期.png" alt=""></p>
<p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的,类的加载过程必须按照这种顺序进行,但是解析阶段不一定.</p>
<p>虚拟机规范严格规定有且只有5种情况必须对类进行”初始化”阶段,而加载,验证,准备自然需要在此之前开始.</p>
<ol>
<li>触发new,getstatic(读取静态字段),putstatic(设置静态字段),invokestatic(调用静态方法)字节码指令时</li>
<li>使用反射对类进行调用时</li>
<li>初始化类的时候,发现父类没初始化,则触发父类初始化</li>
<li>虚拟机启动时,用户指定一个要执行的主类,虚拟机会先初始化这个主类.</li>
<li>当使用JDK1.7的动态语言支持时,如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄,并且这个方法句柄所对应的类没有进行过初始化,则需要先触发其初始化。</li>
</ol>
<p>被动引用不会触发初始化,比如通过子类来调用父类的静态引用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class SuperClass&#123;</div><div class="line">	static&#123;</div><div class="line">		System.out.println(&quot;SuperClass init!&quot;);</div><div class="line">	&#125;</div><div class="line">	public static int value=123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class SubClass extends SuperClass&#123;</div><div class="line">	static&#123;</div><div class="line">		System.out.println(&quot;SubClass init!&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line">*非主动使用类字段演示</div><div class="line">**/</div><div class="line">public class NotInitialization&#123;</div><div class="line">	public static void main(String[]args)&#123;</div><div class="line">		System.out.println(SubClass.value);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该类不会初始化SubClass的初始化.</p>
<h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载是类加载的一个过程.<br>加载阶段,虚拟机要完成以下事情:</p>
<ol>
<li>通过一个类的权限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口.</li>
</ol>
<p>获取二进制字节流,可以多种方式获取,比如jar包内,网络上,文件中等.<br>开发人员可以通过自定义的类加载器去控制字节流的获取方式,即重写一个类加载器的loadClass()方法.<br>Class对象比较特殊,它虽然是对象,但是存储在方法区里面.</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是链接阶段的第一步,这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机要求.<br>虚拟机如果不检查输入的字节流,对其完全信任的话,很可能会因为载入了有害字节流而导致系统崩溃,所以验证是虚拟机对自身保护的一项重要工作.</p>
<p>如果验证到输入的字节流不符合Class文件格式的约束,虚拟机就应抛出一个java.lang.VerifyError异常或其子类异常.<br>验证阶段大致完成下面4个阶段的校验动作:文件格式验证、元数据验证、字节码验证、符号引用验证。<br>文件格式验证阶段,验证字节流是否符合Class文件格式规范,如是否以0xCAFFBABE开头,主次版本号是否符合范围…<br>元数据验证,该类父类是否继承了不被允许继承的类,如果该类不是抽象类,是否实现了其父类要求实现的所有方法等..<br>字节码验证,确定语义合法性,保证被校验类不会做出危害虚拟机安全的事件.<br>符号引用验证,验证符号引用的正确性,如符号引用中通过字符串权限定名是否能找到对应的类,符号引用中的类,字段,方法的访问性(private,protected,public)是否可被当前类访问.</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段,这些变量所使用的内存都将在方法区中进行分配。<br>这个时候内存分配的仅包括被static修饰的变量,而不包括实例变量.<br>对于分配的static变量,其只是零值,如:<code>public static int value = 123</code>,那么准备阶段过后初始值为0.</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>到了初始化阶段,才真正开始执行类中定义的Java程序代码.</p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>##　类与类加载器<br>对于任意一个类,都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性,每一个类加载器,都拥有一个独立的类名称空间．这句话可以表达得更通俗一些:比较两个类是否“相等”,只有在这两个类是由同一个类加载器加载的前提下才有意义,否则,即使这两个类来源于同一个Class文件,被同一个虚拟机加载,只要加载它们的类加载器不同,那这两个类就必定不相等。</p>
<p>这里所指的“相等”,包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果,也包括使用instanceof关键字做对象所属关系判定等情况。</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>从虚拟机角度来说，类加载器有两种，一种是Bootstrap ClassLoader,这个类加载器由C++语言实现,是虚拟机自身一部分,另一种是所有其他类加载器,由Java实现,独立于虚拟机外部,并继承于抽象类java.lang.ClassLoader.</p>
<p>而Java开发人员角度来说,类加载器分三种:启动 类加载器(Bootstrap ClassLoader),扩展 类加载器(Extension ClassLoader),应用程序 类加载器(Application ClassLoader)等.<br>扩展类加载器:负责加载<java_home>\lib\ext目录中的类.<br>应用程序类加载器:通过getSystemClassLoader()取得,所以一般也称为系统类加载器,负责加载用户类路径上所指定的类库.</java_home></p>
<p>如果有必须还可以加入自己定义的类加载器,其加载器之间的关系如:<br><img src="/images/类加载器.png" alt=""></p>
<p>图上所展示的类加载器之间的关系,被称为类加载器的双亲委派模型,双亲委派模型要求除了顶层的启动类加载器外,其他的类加载器都应该有自己的父类加载器.这里的父类加载器不是通过继承实现的,而是通过使用组合关系来实现的.</p>
<p>双亲委派模型的工作过程是:如果一个类加载器收到了类加载的请求,它首先不会自己去尝试加载这个类,而是把这个请求委派给<strong>父类加载器</strong>去完成,每一个层次的类加载器都是如此,因此所有的加载请求最终都应该传送到<strong>顶层</strong>的启动类加载器中,只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时,子加载器才会尝试自己去加载。</p>
<p>使用双亲委派模型来组织类加载器之间的关系,有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object,它存放在rt.jar之中,无论哪一个类加载器要加载这个类,最终都是委派给处于模型最顶端的启动类加载器进行加载,因此Object类在程序的各种类加载器环境中都是同一个类.</p>
<h1 id="JVM字节码执行引擎"><a href="#JVM字节码执行引擎" class="headerlink" title="JVM字节码执行引擎"></a>JVM字节码执行引擎</h1><h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>栈帧是一种存储方法的局部变量表,操作数栈,动态连接和方法返回地址等信息.每一个方法从调用开始至执行完成的过程,都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>
<p>对于执行引擎来说,在活动线程中,只有位于栈顶的栈帧才是有效的,称为当前栈帧(Current StackFrame),与这个栈帧相关联的方法称为当前方法(Current Method)。<br><img src="/images/栈帧的概念结构.png" alt=""></p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表的容量以变量槽(Variable Slot)为最小单位,每个slot都应该能存储boolean,byte,char,short,int,float,reference或returnAddress类型的数据,这8中数据类型,都可以使用32位或更小的物理内存存放,但并不代表slot就占用32位内存空间,slot可以随着处理器,操作系统或虚拟机的不同而变化.</p>
<p>为了尽可能节省栈帧空间,局部变量表中的Slot是可以重用的.在某些情况下,slot的复用会影响到系统的垃圾收集行为.如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static void main(String[]args)()&#123;</div><div class="line">	byte[]placeholder=new byte[64*1024*1024];</div><div class="line">	System.gc();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>gc后并不会回收64M数据.没有回收placeholder所占的内存能说得过去,因为在执行System.gc()时,变量placeholder还处于作用域之内,虚拟机自然不敢回收placeholder的内存。但是看下面代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static void main(String[]args)()&#123;</div><div class="line">	&#123;</div><div class="line">		byte[]placeholder=new byte[64*1024*1024];</div><div class="line">	&#125;</div><div class="line">	System.gc();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个时候,执行gc后,依然没有释放64M内存.在看下面代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static void main(String[]args)()&#123;</div><div class="line">	&#123;</div><div class="line">	byte[]placeholder=new byte[64*1024*1024];</div><div class="line">	&#125;</div><div class="line">	int a=0;</div><div class="line">	System.gc();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行后,发现64M内存被释放了.<br>被回收的原因是:局部变量表中<br>的Slot是否还存有关于placeholder数组对象的引用。第一次修改中,代码虽然已经离开了placeholder的作用域,但在此之后,没有任何对局部变量表的读写操作,placeholder原本所占用的Slot还没有被其他变量所复用,所以作为GC Roots一部分的局部变量表仍然保持着对它的关联。这种关联没有被及时打断,在绝大部分情况下影响都很轻微。但如果遇到一个方法,其后面的代码有一些耗时很长的操作,而前面又定义了占用了大量内存、实际上已经不会再使用的变量,手动将其设置为null值(用来代替那句int a=0,把变量对应的局部变量表Slot清空)便不见得是一个绝对无意义的操作.</p>
<p>虽然如此,但是不能把赋null值当做编码规则来推广.</p>
<h2 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h2><p>分派调用过程将会揭示多态性特征的一些最基本的体现.</p>
<h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p>如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class StaticDispatch&#123;</div><div class="line">	static abstract class Human&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	static class Man extends Human&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	static class Woman extends Human&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void sayHello(Human guy)&#123;</div><div class="line">		System.out.println(&quot;hello,guy!&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void sayHello(Man guy)&#123;</div><div class="line">		System.out.println(&quot;hello,gentleman!&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void sayHello(Woman guy)&#123;</div><div class="line">		System.out.println(&quot;hello,lady!&quot;);</div><div class="line">	&#125;</div><div class="line">	public static void main(String[]args)&#123;</div><div class="line">		Human man=new Man();</div><div class="line">		Human woman=new Woman();</div><div class="line">		StaticDispatch sr=new StaticDispatch();</div><div class="line">		sr.sayHello(man);</div><div class="line">		sr.sayHello(woman);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行结果是:<br>hello,guy!<br>hello,guy!</p>
<p>对于<code>Human man = new Man()</code>,左部<code>Human man</code>被称为静态类型,在编译时期不可变,只能在运行时期发生变化,而右部<code>new Man()</code>是实际类型只能在运行时期才能确定,在编译时候,编译器并不知道一个静态类型的实际类型是什么.所以对于上述代码其使用哪个重载,完全取决于传入对象的静态类型.因此,在编译时期,javac编译器会根据参数的静态类型决定使用哪个重载版本.</p>
<p>所有依赖静态类型来定位方法执行版本的分派动作被称为静态分派.静态分派的典型应用是方法重载,静态分派发生在编译阶段.</p>
<h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p>动态分派和重写有着密切的关系,首先查看代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class DynamicDispatch&#123;</div><div class="line">	static abstract class Human&#123;</div><div class="line">		protected abstract void sayHello();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	static class Man extends Human&#123;</div><div class="line">		@Override</div><div class="line">		protected void sayHello()&#123;</div><div class="line">			System.out.println(&quot;man say hello&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	static class Woman extends Human&#123;</div><div class="line">		@Override</div><div class="line">		protected void sayHello()&#123;</div><div class="line">			System.out.println(&quot;woman say hello&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[]args)&#123;</div><div class="line">		Human man=new Man();</div><div class="line">		Human woman=new Woman();</div><div class="line">		man.sayHello();</div><div class="line">		woman.sayHello();</div><div class="line">		man=new Woman();</div><div class="line">		man.sayHello();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果:<br>man say hello<br>woman say hello<br>woman say hello</p>
<p>其过程是,找到实际对象的方法后返回其引用,如果没有找到方法,则在继承中从下到上依次查找,直到找到为止.<br>将在运行期根据实际类型确定方法执行版本的分派过程称为动态分派.</p>
<h3 id="虚拟机动态分派"><a href="#虚拟机动态分派" class="headerlink" title="虚拟机动态分派"></a>虚拟机动态分派</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Dispatch&#123;</div><div class="line">	static class QQ&#123;&#125;</div><div class="line">	static class_360&#123;&#125;</div><div class="line"></div><div class="line">	public static class Father&#123;</div><div class="line">		public void hardChoice(QQ arg)&#123;</div><div class="line">			System.out.println(&quot;father choose qq&quot;);</div><div class="line">		&#125;</div><div class="line">		public void hardChoice(_360 arg)&#123;</div><div class="line">			System.out.println(&quot;father choose 360&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static class Son extends Father&#123;</div><div class="line">		public void hardChoice(QQ arg)&#123;</div><div class="line">			System.out.println(&quot;son choose qq&quot;);</div><div class="line">		&#125;</div><div class="line">		public void hardChoice(_360 arg)&#123;</div><div class="line">			System.out.println(&quot;son choose 360&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[]args)&#123;</div><div class="line">		Father father=new Father();</div><div class="line">		Father son=new Son();</div><div class="line">		father.hardChoice(new_360());</div><div class="line">		son.hardChoice(new QQ());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基于性能考虑,虚拟机的实现是建立一个虚方法表,使用虚方法表索引来代替元数据查找以提高性能.如下图:<br><img src="/images/方法表结构.png" alt=""></p>
<p>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写,那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的,都指向父类的实现入口。如果子类中重写了这个方法,子类方法表中的地址将会替换为指向子类实现版本的入口地址。如上图中,Son重写了来自Father的全部方法,因此Son的方法表没有指向Father类型数据的箭头。但是Son和Father都没有重写来自Object的方法,所以它们的方法表中所有从Object继承来的方法都指向了Object的数据类型。</p>
<h2 id="动态类型语言"><a href="#动态类型语言" class="headerlink" title="动态类型语言"></a>动态类型语言</h2><p>动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译器.而Java和C++等就是最常用的静态类型语言.</p>
<p>静态语言显著特征就是编译期间进行严格类型检查,而动态语言只是在运行期间确定类型.</p>
<h2 id="java-lang-invoke"><a href="#java-lang-invoke" class="headerlink" title="java.lang.invoke"></a>java.lang.invoke</h2><p>在Java中无法传递函数引用,而在C/C++可以传递指针来代表函数,对于动态语言,也可以将函数当一个参数传递.<br>不过在拥有MethodHandler之后,Java语言也可以拥有类似函数指针或者委托的方法别名的工具了.如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class MethodHandleTest&#123;</div><div class="line">	static class ClassA&#123;</div><div class="line">		public void println(String s)&#123;</div><div class="line">			System.out.println(s);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[]args)throws Throwable&#123;</div><div class="line">		Object obj=System.currentTimeMillis()%2==0?System.out:new ClassA();</div><div class="line">		/*无论obj最终是哪个实现类,下面这句都能正确调用到println方法</div><div class="line">		getPrintlnMH(obj).invokeExact(&quot;icyfenix&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static MethodHandle getPrintlnMH(Object reveiver)throws Throwable&#123;</div><div class="line">		/*MethodType:代表“方法类型”,包含了方法的返回值(methodType()的第一个参数)和具体参数(methodType()第二个及以后的参数)*/</div><div class="line">		MethodType mt=MethodType.methodType(void.class,String.class);</div><div class="line">		/*lookup()方法来自于MethodHandles.lookup,这句的作用是在指定类中查找符合给定的方法名称、方法类型,并且符合调用权限的方法句柄*/</div><div class="line">		/*因为这里调用的是一个虚方法,按照Java语言的规则,方法第一个参数是隐式的,代表该方法的接收者,也即是this指向的对象,这个参数以前是放在参数列表中进行传递的,而现在提供了bindTo()方法来完</div><div class="line">		成这件事情*/</div><div class="line">		return lookup().findVirtual(reveiver.getClass(),&quot;println&quot;,mt).bindTo(reveiver);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上方法测试的时候并没有成功.= =</p>
<p>一般来说,这个方法可以做的事情,使用反射也可以做,但是反射是重量级,而MethodHandler是轻量级.</p>
<h1 id="JVM常见面试题"><a href="#JVM常见面试题" class="headerlink" title="JVM常见面试题"></a>JVM常见面试题</h1>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/01/springMVC学习/" rel="next" title="springMVC学习">
                <i class="fa fa-chevron-left"></i> springMVC学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/05/Linux-下-mysql导入-sql文件/" rel="prev" title="Linux 下 mysql导入.sql文件">
                Linux 下 mysql导入.sql文件 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/04/03/JVM学习/"
           data-title="JVM学习" data-url="http://yoursite.com/2017/04/03/JVM学习/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="QxG" />
          <p class="site-author-name" itemprop="name">QxG</p>
          <p class="site-description motion-element" itemprop="description">努力才会有机遇</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">49</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#内存"><span class="nav-number">1.</span> <span class="nav-text">内存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#程序计数器"><span class="nav-number">1.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟机栈"><span class="nav-number">1.2.</span> <span class="nav-text">虚拟机栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本地方法栈"><span class="nav-number">1.3.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA堆"><span class="nav-number">1.4.</span> <span class="nav-text">JAVA堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法区"><span class="nav-number">1.5.</span> <span class="nav-text">方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时常量池"><span class="nav-number">1.5.1.</span> <span class="nav-text">运行时常量池</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对象"><span class="nav-number">2.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的创建"><span class="nav-number">2.1.</span> <span class="nav-text">对象的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的内存布局"><span class="nav-number">2.2.</span> <span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象访问定位"><span class="nav-number">2.3.</span> <span class="nav-text">对象访问定位</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#垃圾收集器和内存分配策略"><span class="nav-number">3.</span> <span class="nav-text">垃圾收集器和内存分配策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象是否存活"><span class="nav-number">3.1.</span> <span class="nav-text">对象是否存活</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引用计数法"><span class="nav-number">3.1.1.</span> <span class="nav-text">引用计数法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可达性分析法"><span class="nav-number">3.1.2.</span> <span class="nav-text">可达性分析法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用"><span class="nav-number">3.2.</span> <span class="nav-text">引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生存还是死亡"><span class="nav-number">3.3.</span> <span class="nav-text">生存还是死亡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回收方法区"><span class="nav-number">3.4.</span> <span class="nav-text">回收方法区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集算法"><span class="nav-number">3.5.</span> <span class="nav-text">垃圾收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标记-清除算法"><span class="nav-number">3.5.1.</span> <span class="nav-text">标记-清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制算法"><span class="nav-number">3.5.2.</span> <span class="nav-text">复制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标记-整理算法"><span class="nav-number">3.5.3.</span> <span class="nav-text">标记-整理算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分代收集算法"><span class="nav-number">3.5.4.</span> <span class="nav-text">分代收集算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HotSpot采用的算法"><span class="nav-number">3.5.5.</span> <span class="nav-text">HotSpot采用的算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集器"><span class="nav-number">3.6.</span> <span class="nav-text">垃圾收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存分配与回收策略"><span class="nav-number">3.7.</span> <span class="nav-text">内存分配与回收策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虚拟机性能监控及故障处理"><span class="nav-number">4.</span> <span class="nav-text">虚拟机性能监控及故障处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK可视化工具"><span class="nav-number">4.1.</span> <span class="nav-text">JDK可视化工具</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类文件结构"><span class="nav-number">5.</span> <span class="nav-text">类文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#魔数与Class文件的版本"><span class="nav-number">5.1.</span> <span class="nav-text">魔数与Class文件的版本</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虚拟机类加载机制"><span class="nav-number">6.</span> <span class="nav-text">虚拟机类加载机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类加载的过程"><span class="nav-number">7.</span> <span class="nav-text">类加载的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#加载"><span class="nav-number">7.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#验证"><span class="nav-number">7.2.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#准备"><span class="nav-number">7.3.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解析"><span class="nav-number">7.4.</span> <span class="nav-text">解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化"><span class="nav-number">7.5.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类加载器"><span class="nav-number">8.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#双亲委派模型"><span class="nav-number">8.1.</span> <span class="nav-text">双亲委派模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM字节码执行引擎"><span class="nav-number">9.</span> <span class="nav-text">JVM字节码执行引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#运行时栈帧结构"><span class="nav-number">9.1.</span> <span class="nav-text">运行时栈帧结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#局部变量表"><span class="nav-number">9.1.1.</span> <span class="nav-text">局部变量表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分派"><span class="nav-number">9.2.</span> <span class="nav-text">分派</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态分派"><span class="nav-number">9.2.1.</span> <span class="nav-text">静态分派</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态分派"><span class="nav-number">9.2.2.</span> <span class="nav-text">动态分派</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟机动态分派"><span class="nav-number">9.2.3.</span> <span class="nav-text">虚拟机动态分派</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态类型语言"><span class="nav-number">9.3.</span> <span class="nav-text">动态类型语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-lang-invoke"><span class="nav-number">9.4.</span> <span class="nav-text">java.lang.invoke</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM常见面试题"><span class="nav-number">10.</span> <span class="nav-text">JVM常见面试题</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QxG</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"qxgzone"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  

  

  

  

  


</body>
</html>
